{
    "primary_language": "C++",
    "language_guidelines": "# General Guidelines : \n**General Guidelines for C/C++ Projects**\n\n1. **Read the README**  \n   Start by reading the project's README file on GitHub. It contains important instructions for installation, usage, and project-specific details.  \n\n2. **Check Dependencies**  \n   Look for dependencies listed in the README or package management files like `CMakeLists.txt` (for CMake), `Makefile` (for Make), or `vcpkg.json` (for vcpkg). Ensure the required compiler and libraries are installed.  \n\n3. **Build Tool**  \n   Identify the build tool the project is using: Make, CMake, or another. This information should be available in the README or through project configuration files (e.g., `Makefile` for Make, `CMakeLists.txt` for CMake).  \n\n4. **Build the Project**  \n   Depending on the build tool, use the appropriate commands to build the project:  \n\n   - For Make:  \n     ```  \n     make  \n     ```  \n   - For CMake:  \n     ```  \n     mkdir build  \n     cd build  \n     cmake ..  \n     make  \n     ```  \n\n5. **Configuration**  \n   Check if the project requires configuration files (e.g., `.conf` files, `config.h` headers) to be set up. This may involve providing paths to dependencies or setting compilation flags.  \n\n6. **Run Tests (if available)**  \n   If the project provides tests, it's a good idea to run them to ensure everything is working correctly. Common testing frameworks for C/C++ include Google Test (gtest), Catch2, and Boost.Test.  \n   - For Google Test:  \n     ```  \n     ./path/to/test_executable  \n     ```  \n   - For Catch2:  \n     ```  \n     ./path/to/test_executable  \n     ```  \n\n7. **Run the Project**  \n   Follow the instructions in the README to run the project. This could involve running a specific executable, starting a server, or executing a specific command.  \n\n8. **Troubleshooting**  \n   If you encounter issues during installation or while running the project, refer to the project's issue tracker on GitHub or search for similar issues.  \n\n9. **Documentation**  \n   Review additional documentation such as Doxygen files, API documentation, or inline comments in the code. Understanding the documentation provides better insights into the project\u2019s structure and usage.  ",
    "workflow_guidelines": "",
    "readme": "# Halide\n\nHalide is a programming language designed to make it easier to write\nhigh-performance image and array processing code on modern machines. Halide\ncurrently targets:\n\n- CPU architectures: X86, ARM, Hexagon, PowerPC, RISC-V\n- Operating systems: Linux, Windows, macOS, Android, iOS, Qualcomm QuRT\n- GPU Compute APIs: CUDA, OpenCL, Apple Metal, Microsoft Direct X 12, Vulkan\n\nRather than being a standalone programming language, Halide is embedded in C++.\nThis means you write C++ code that builds an in-memory representation of a\nHalide pipeline using Halide's C++ API. You can then compile this representation\nto an object file, or JIT-compile it and run it in the same process. Halide also\nprovides a Python binding that provides full support for writing Halide embedded\nin Python without C++.\n\nHalide requires C++17 (or later) to use.\n\nFor more detail about what Halide is, see https://halide-lang.org.\n\nFor API documentation see https://halide-lang.org/docs.\n\nFor some example code, read through the tutorials online\nat https://halide-lang.org/tutorials. The corresponding code is in the\n`tutorials/` directory. Larger examples are in the `apps/` directory.\n\nIf you've acquired a full source distribution and want to build Halide, see the\n[notes below](#building-halide).\n\n# Getting Halide\n\n## Pip\n\nAs of Halide 19.0.0, we provide binary wheels on PyPI. Halide provides bindings\nfor C++ and Python. Even if you only intend to use Halide from C++, pip may be\nthe easiest way to get a binary build of Halide.\n\nFull releases may be installed with `pip` like so:\n\n```shell\n$ pip install halide\n```\n\nEvery commit to `main` is published to Test PyPI as a development version and\nthese may be installed with a few extra flags:\n\n```shell\n$ pip install halide --pre --extra-index-url https://test.pypi.org/simple\n```\n\nCurrently, we provide wheels for: Windows x86-64, macOS x86-64, macOS arm64, and\nLinux x86-64. The Linux wheels are built for manylinux_2_28, which makes them\nbroadly compatible (Debian 10, Ubuntu 18.10, Fedora 29).\n\n*For C++ usage of the pip package:* On Linux and macOS, CMake's `find_package`\ncommand should find Halide as long as you're in the same virtual environment you\ninstalled it in. On Windows, you will need to add the virtual environment root\ndirectory to `CMAKE_PREFIX_PATH`. This can be done by running\n`set CMAKE_PREFIX_PATH=%VIRTUAL_ENV%` in `cmd`.\n\nOther build systems can find the Halide root path by running `python -c \n\"import halide; print(halide.install_dir())\"`.\n\n## Homebrew\n\nAlternatively, if you use macOS, you can install Halide via\n[Homebrew](https://brew.sh/) like so:\n\n```\n$ brew install halide\n```\n\n## Binary tarballs\n\nThe latest version of Halide can always be found on GitHub\nat https://github.com/halide/Halide/releases\n\nWe provide binary releases for many popular platforms and architectures,\nincluding 32/64-bit x86 Windows, 64-bit x86/ARM macOS, and 32/64-bit x86/ARM\nUbuntu Linux.\n\nThe macOS releases are built using XCode's command-line tools with Apple Clang\n500.2.76. This means that we link against libc++ instead of libstdc++. You may\nneed to adjust compiler options accordingly if you're using an older XCode which\ndoes not default to libc++.\n\nWe use a recent Ubuntu LTS to build the Linux releases; if your distribution is\ntoo old, it might not have the requisite glibc. \n\nNightly builds of Halide and the LLVM versions we use in CI are also available\nat https://buildbot.halide-lang.org/\n\n## Vcpkg\n\nIf you use [vcpkg](https://github.com/microsoft/vcpkg) to manage dependencies,\nyou can install Halide via:\n\n```\n$ vcpkg install halide:x64-windows # or x64-linux/x64-osx\n```\n\nOne caveat: vcpkg installs only the minimum Halide backends required to compile\ncode for the active platform. If you want to include all the backends, you\nshould install `halide[target-all]:x64-windows` instead. Note that since this\nwill build LLVM, it will take a _lot_ of disk space (up to 100GB).\n\n## Other package managers\n\nWe are interested in bringing Halide to other popular package managers and Linux\ndistribution repositories! We track the status of various distributions of\nHalide [in this GitHub issue](https://github.com/halide/Halide/issues/4660). If\nyou have experience publishing packages we would be happy to work with you!\n\n# Building Halide\n\n## Platform Support\n\nThere are two sets of platform requirements relevant to Halide: those required\nto run the compiler library in either JIT or AOT mode, and those required to run\nthe _binary outputs_ of the AOT compiler.\n\nThese are the **tested** host toolchain and platform combinations for building\nand running the Halide compiler library.\n\n| Compiler   | Version      | OS                     | Architectures |\n|------------|--------------|------------------------|---------------|\n| GCC        | 9.5          | Ubuntu Linux 20.04 LTS | x86, x64      |\n| GCC        | 11.4         | Ubuntu Linux 22.04 LTS | ARM32, ARM64  |\n| MSVC       | 2022 (19.37) | Windows 11 (22631)     | x86, x64      |\n| AppleClang | 15.0.0       | macOS 14.4.1           | x64           |\n| AppleClang | 14.0.0       | macOS 14.6             | ARM64         |\n\nSome users have successfully built Halide for Linux using Clang 9.0.0+, for\nWindows using ClangCL 11.0.0+, and for Windows ARM64 by cross-compiling with\nMSVC. We do not actively test these scenarios, however, so your mileage may\nvary.\n\nBeyond these, we are willing to support (by accepting PRs for) platform and\ntoolchain combinations that still receive _active, first-party, public support_\nfrom their original vendors. For instance, at time of writing, this excludes\nWindows 7 and includes Ubuntu 18.04 LTS.\n\nCompiled AOT pipelines are expected to have much broader platform support. The\nbinaries use the C ABI, and we expect any compliant C compiler to be able to use\nthe generated headers correctly. The C++ bindings currently require C++17. If\nyou discover a compatibility problem with a generated pipeline, please open an\nissue.\n\n## Acquiring LLVM\n\nAt any point in time, building Halide requires either the latest stable version\nof LLVM, the previous stable version of LLVM, or trunk. At the time of writing,\nthis means versions 19, 18, and 17 are supported, but 16 is not.\n\nIt is simplest to get a binary release of LLVM on macOS by using\n[Homebrew](https://brew.sh). Just run `brew install llvm`. On Debian flavors of\nLinux, the [LLVM APT repo](https://apt.llvm.org) is best; use the provided\ninstallation script. We know of no suitable official binary releases for\nWindows, however the ones we use in CI can usually be found at\nhttps://buildbot.halide-lang.org, along with tarballs for our other tested\nplatforms. See [the section on Windows](#windows) below for further advice.\n\nIf your OS does not have packages for LLVM, or you want more control over the\nconfiguration, you can build it yourself. First check it out from GitHub:\n\n```shell\n$ git clone --depth 1 --branch llvmorg-18.1.8 https://github.com/llvm/llvm-project.git\n```\n\n(LLVM 18.1.8 is the most recent released LLVM at the time of writing. For\ncurrent trunk, use `main` instead)\n\nThen build it like so:\n\n```shell\n$ cmake -G Ninja -S llvm-project/llvm -B build \\\n        -DCMAKE_BUILD_TYPE=Release \\\n        -DLLVM_ENABLE_PROJECTS=\"clang;lld;clang-tools-extra\" \\\n        -DLLVM_ENABLE_RUNTIMES=compiler-rt \\\n        -DLLVM_TARGETS_TO_BUILD=\"WebAssembly;X86;AArch64;ARM;Hexagon;NVPTX;PowerPC;RISCV\" \\\n        -DLLVM_ENABLE_ASSERTIONS=ON \\\n        -DLLVM_ENABLE_EH=ON \\\n        -DLLVM_ENABLE_RTTI=ON \\\n        -DLLVM_ENABLE_HTTPLIB=OFF \\\n        -DLLVM_ENABLE_LIBEDIT=OFF \\\n        -DLLVM_ENABLE_LIBXML2=OFF \\\n        -DLLVM_ENABLE_TERMINFO=OFF \\\n        -DLLVM_ENABLE_ZLIB=OFF \\\n        -DLLVM_ENABLE_ZSTD=OFF \\\n        -DLLVM_BUILD_32_BITS=OFF\n$ cmake --build build\n$ cmake --install build --prefix llvm-install\n```\n\nThis will produce a working LLVM installation in `$PWD/llvm-install`. We refer\nto this path as `LLVM_ROOT` later. **Do not confuse this installation tree with\nthe build tree!**\n\nLLVM takes a long time to build, so the above command uses Ninja to maximize\nparallelism. If you choose to omit `-G Ninja`, Makefiles will be generated\ninstead. In this case, enable parallelism with `cmake --build build -j NNN`\nwhere `NNN` is the number of parallel jobs, i.e. the number of CPUs you have.\n\nNote that you _must_ add `clang` and `lld` to `LLVM_ENABLE_PROJECTS` and\n`WebAssembly` and `X86` _must_ be included in `LLVM_TARGETS_TO_BUILD`.\n`LLVM_ENABLE_RUNTIMES=compiler-rt` is only required to build the fuzz tests, and\n`clang-tools-extra` is only necessary if you plan to contribute code to Halide\n(so that you can run `clang-tidy` on your pull requests). You can disable\nexception handling (EH) and RTTI if you don't want the Python bindings. We\nrecommend enabling the full set to simplify builds during development.\n\n## Building Halide with CMake\n\nThis is discussed in greater detail in [BuildingHalideWithCMake.md]. CMake\nversion 3.28+ is required to build Halide.\n\n[BuildingHalideWithCMake.md]: doc/BuildingHalideWithCMake.md\n\n### MacOS and Linux\n\nFollow the above instructions to build LLVM or acquire a suitable binary\nrelease. Then change directory to the Halide repository and run:\n\n```shell\n$ cmake -G Ninja  -S . -B build -DCMAKE_BUILD_TYPE=Release -DHalide_LLVM_ROOT=$LLVM_ROOT\n$ cmake --build build\n```\n\nSetting `-DHalide_LLVM_ROOT` is not required if you have a suitable system-wide\nversion installed. However, if you have multiple LLVMs installed, it can pick\nbetween them.\n\n### Windows\n\nWe suggest building with Visual Studio 2022. Your mileage may vary with earlier\nversions. Be sure to install the \"C++ CMake tools for Windows\" in the Visual\nStudio installer. For older versions of Visual Studio, do not install the CMake\ntools, but instead acquire CMake and Ninja from their respective project\nwebsites.\n\nThese instructions start from the `D:` drive. We assume this git repo is cloned\nto `D:\\Halide`. We also assume that your shell environment is set up correctly.\nFor a 64-bit build, run:\n\n```\nD:\\> \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2022\\Community\\VC\\Auxiliary\\Build\\vcvarsall.bat\" x64\n```\n\nFor a 32-bit build, run:\n\n```\nD:\\> \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2022\\Community\\VC\\Auxiliary\\Build\\vcvarsall.bat\" x64_x86\n```\n\n#### Managing dependencies with vcpkg\n\nThe best way to get compatible dependencies on Windows is to use\n[vcpkg](https://github.com/Microsoft/vcpkg). Install it like so:\n\n```\nD:\\> git clone https://github.com/Microsoft/vcpkg.git\nD:\\> cd vcpkg\nD:\\vcpkg> .\\bootstrap-vcpkg.bat -disableMetrics\n...\nCMake projects should use: \"-DCMAKE_TOOLCHAIN_FILE=D:/vcpkg/scripts/buildsystems/vcpkg.cmake\"\n```\n\nWhen using the toolchain file, vcpkg will automatically build all the necessary\ndependencies. However, as stated above, be aware that acquiring LLVM this way\nmay use over 100 GB of disk space for its build trees and take a very long time\nto build. You can manually delete the build trees afterward, but vcpkg will not\ndo this automatically.\n\nSee [BuildingHalideWithCMake.md](./doc/BuildingHalideWithCMake.md#vcpkg-presets)\nfor directions to use Vcpkg for everything _except_ LLVM.\n\n#### Building Halide\n\nCreate a separate build tree and call CMake with vcpkg's toolchain. This will\nbuild in either 32-bit or 64-bit depending on the environment script (`vcvars`)\nthat was run earlier.\n\n```\nD:\\Halide> cmake -G Ninja -S . -B build ^\n                 --toolchain D:/vcpkg/scripts/buildsystems/vcpkg.cmake ^\n                 -DCMAKE_BUILD_TYPE=Release\n```\n\nThen run the build with:\n\n```\nD:\\Halide> cmake --build build\n```\n\nTo run all the tests:\n\n```\nD:\\Halide> ctest --test-dir build --output-on-failure\n```\n\nSubsets of the tests can be selected with `-L` and include `correctness`,\n`generator`, `error`, and the other directory names under `tests/`.\n\n#### Building LLVM (optional)\n\nFollow these steps if you want to build LLVM yourself. First, download LLVM's\nsources (these instructions use the 18.1.8 release).\n\n```\nD:\\> git clone --depth 1 --branch llvm-org-18.1.8 https://github.com/llvm/llvm-project.git\n```\n\nAs above, run `vcvarsall.bat` to pick between x86 and x64. Then configure LLVM\nwith the following command (for 32-bit, set `-DLLVM_BUILD_32_BITS=ON` instead):\n\n```\nD:\\> cmake -G Ninja -S llvm-project\\llvm -B build ^\n           -DCMAKE_BUILD_TYPE=Release ^\n           -DLLVM_ENABLE_PROJECTS=clang;lld;clang-tools-extra ^\n           -DLLVM_ENABLE_RUNTIMES=compiler-rt ^\n           -DLLVM_TARGETS_TO_BUILD=WebAssembly;X86;AArch64;ARM;Hexagon;NVPTX;PowerPC;RISCV ^\n           -DLLVM_ENABLE_ASSERTIONS=ON ^\n           -DLLVM_ENABLE_EH=ON ^\n           -DLLVM_ENABLE_RTTI=ON ^\n           -DLLVM_ENABLE_HTTPLIB=OFF ^\n           -DLLVM_ENABLE_LIBEDIT=OFF ^\n           -DLLVM_ENABLE_LIBXML2=OFF ^\n           -DLLVM_ENABLE_TERMINFO=OFF ^\n           -DLLVM_ENABLE_ZLIB=OFF ^\n           -DLLVM_ENABLE_ZSTD=OFF ^\n           -DLLVM_BUILD_32_BITS=OFF\n```\n\n**MSBuild:** If you want to build LLVM with MSBuild instead of Ninja, use\n`-G \"Visual Studio 17 2022\" -Thost=x64 -A x64` or\n`-G \"Visual Studio 17 2022\" -Thost=x64 -A Win32` in place of `-G Ninja`.\n\nFinally, run the build and install to a local directory:\n\n```\nD:\\> cmake --build build --config Release\nD:\\> cmake --install build --prefix llvm-install\n```\n\nYou can substitute `Debug` for `Release` in the above `cmake` commands if you\nwant a debug build.\n\nTo use this with Halide, but still allow vcpkg to manage other dependencies, you\nmust add two flags to Halide's CMake configure command line. First, disable LLVM\nwith `-DVCPKG_OVERLAY_PORTS=cmake/vcpkg`. Second, point CMake to our newly built\nHalide with `-DHalide_LLVM_ROOT=D:/llvm-install`.\n\n#### If all else fails...\n\nDo what the buildbots do: https://buildbot.halide-lang.org/master/#/builders\n\nIf the row that best matches your system is red, then maybe things aren't just\nbroken for you. If it's green, then you can click through to the latest build\nand see the commands that the build bots run. Open a step (\"Configure Halide\" is\nuseful) and look at the \"stdio\" logs in the viewer. These logs contain the full\ncommands that were run, as well as the environment variables they were run with.\n\n## Building Halide with make\n\n> [!WARNING]\n> We do not provide support for the Makefile. Feel free to use it, but if\n> anything goes wrong, switch to the CMake build. Note also that the Makefile\n> cannot build the Python bindings or produce install packages.\n\n*TL;DR*: Have LLVM 17 (or greater) installed and run `make` in the root\ndirectory of the repository (where this README is).\n\nBy default, `make` will use the `llvm-config` tool found in the `PATH`. If you\nwant to use a different LLVM, such as a custom-built one following the\ninstructions above, set the following environment variable:\n\n```shell\n$ export LLVM_CONFIG=\"$LLVM_ROOT/bin/llvm-config\"\n```\n\nNow you should be able to just run `make` in the root directory of the Halide\nsource tree. `make run_tests` will run the JIT test suite, and `make test_apps`\nwill make sure all the apps compile and run (but won't check their output).\n\nWhen building the tests, you can set the AOT compilation target with the \n`HL_TARGET` environment variable.\n\n### Building Halide out-of-tree with make\n\nIf you wish to build Halide in a separate directory, you can do that like so:\n\n```shell\n$ cd ..\n$ mkdir halide_build\n$ cd halide_build\n$ make -f ../Halide/Makefile\n```\n\n# Some useful environment variables\n\n`HL_JIT_TARGET=...` will set Halide's JIT compilation target.\n\n`HL_DEBUG_CODEGEN=1` will print out pseudocode for what Halide is compiling.\nHigher numbers will print more detail.\n\n`HL_NUM_THREADS=...` specifies the number of threads to create for the thread\npool. When the async scheduling directive is used, more threads than this number\nmay be required and thus allocated. A maximum of 256 threads is allowed. (By\ndefault, the number of cores on the host is used.)\n\n`HL_TRACE_FILE=...` specifies a binary target file to dump tracing data into\n(ignored unless at least one `trace_` feature is enabled in the target). The\noutput can be parsed programmatically by starting from the code in\n`utils/HalideTraceViz.cpp`.\n\n# Further references\n\nWe have more documentation in `doc/`, the following links might be helpful:\n\n| Document                                      | Description                                                               |\n|-----------------------------------------------|---------------------------------------------------------------------------|\n| [CMake build](doc/BuildingHalideWithCMake.md) | How to configure and build Halide using CMake.                            |\n| [CMake package](doc/HalideCMakePackage.md)    | How to use the Halide CMake package to build your code.                   |\n| [Hexagon](doc/Hexagon.md)                     | How to use the Hexagon backend.                                           |\n| [Python](doc/Python.md)                       | Documentation for the Python bindings.                                    |\n| [RunGen](doc/RunGen.md)                       | How to use the RunGen interface to run and benchmark arbitrary pipelines. |\n| [Vulkan](doc/Vulkan.md)                       | How to use the Halide Vulkan backend (BETA)                               |\n| [WebAssembly](doc/WebAssembly.md)             | How to use the WebAssembly backend and how to use V8 in place of wabt.    |\n| [WebGPU](doc/WebGPU.md)                       | How to run WebGPU pipelines (BETA)                                        |\n\nThe following links are of greater interest to developers wishing to contribute\ncode to Halide:\n\n| Document                                 | Description                                                                                                   |\n|------------------------------------------|---------------------------------------------------------------------------------------------------------------|\n| [CMake developer](doc/CodeStyleCMake.md) | Guidelines for authoring new CMake code.                                                                      |\n| [FuzzTesting](doc/FuzzTesting.md)        | Information about fuzz testing the Halide compiler (rather than pipelines). Intended for internal developers. |\n| [Testing](doc/Testing.md)                | Information about our test organization and debugging tips. Intended for internal developers.                 |\n",
    "org": "halide",
    "repo": "Halide",
    "number": 8490,
    "commit": "166cd92b2100f3bbde989cbe26def7063c9c8e0a"
}