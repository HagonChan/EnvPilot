{
    "primary_language": "Java",
    "language_guidelines": "# General Guidelines:\n**General Guidelines for Java Projects**\n\n1. **Read the README**  \n   Start by reading the project's README file on GitHub. It often contains important instructions for installation, usage, and any project-specific details.  \n\n2. **Check Dependencies**  \n   Look for any dependencies listed in the README or in configuration files like `pom.xml` (for Maven) or `build.gradle` (for Gradle). Ensure you have the required JDK version installed.  \n\n3. **Build Tool**  \n   Identify which build tool the project is using: Maven or Gradle. This information should be available in the README or through project configuration files (`pom.xml` for Maven, `build.gradle` for Gradle).  \n\n4. **Build the Project**  \n   Use the appropriate commands based on the build tool:  \n   - For Maven:  \n     ```  \n     mvn clean install  \n     ```  \n   - For Gradle:  \n     ```  \n     gradle build  \n     ```  \n\n5. **Configuration**  \n   Check if the project requires any configuration files (e.g., property files, YAML files) and set them up accordingly.  \n\n6. **Run Tests (if available)**  \n   If the project provides tests, it\u2019s a good idea to run them to ensure everything is working correctly.  \n\n7. **Run the Project**  \n   Follow the instructions in the README to run the project. This could involve running a specific class, starting a server, or executing a specific command.  \n\n8. **Troubleshooting**  \n   If you encounter any issues during installation or while running the project, refer to the project\u2019s issue tracker on GitHub or search for similar issues others may have encountered.  \n\n9. **Test Suite Results**  \n   When running a test suite, it is normal for some test cases to fail. If the percentage of failing test cases is less than 20% of the total number, it is considered acceptable, and further investigation is usually not necessary.  ",
    "workflow_guidelines": "\nThe following workflow files might contain information on how to set up the project and run test cases.  This might be useful later on when building/installing and testing the project:\n\nfile: graalvm-latest.yml\nContent:\n# WARNING: Do not edit this file directly. Instead, go to:\n#\n# https://github.com/micronaut-projects/micronaut-project-template/tree/master/.github/workflows\n#\n# and edit them there. Note that it will be sync'ed to all the Micronaut repos\nname: GraalVM Latest CI\non:\n  push:\n    branches:\n      - master\n      - '[1-9]+.[0-9]+.x'\n  pull_request:\n    branches:\n      - master\n      - '[1-9]+.[0-9]+.x'\njobs:\n  build_matrix:\n    if: github.repository != 'micronaut-projects/micronaut-project-template'\n    runs-on: ubuntu-latest\n    env:\n      GRADLE_ENTERPRISE_ACCESS_KEY: ${{ secrets.GRADLE_ENTERPRISE_ACCESS_KEY }}\n      GRADLE_ENTERPRISE_CACHE_USERNAME: ${{ secrets.GRADLE_ENTERPRISE_CACHE_USERNAME }}\n      GRADLE_ENTERPRISE_CACHE_PASSWORD: ${{ secrets.GRADLE_ENTERPRISE_CACHE_PASSWORD }}\n    outputs:\n      matrix: ${{ steps.build-matrix.outputs.matrix }}\n    steps:\n      - uses: actions/checkout@v4\n      - name: Build Matrix\n        uses: micronaut-projects/github-actions/graalvm/build-matrix@master\n        id: build-matrix\n  build:\n    needs: build_matrix\n    if: github.repository != 'micronaut-projects/micronaut-project-template'\n    runs-on: ubuntu-latest\n    strategy:\n      max-parallel: 6\n      matrix:\n        java: ['17', '21']\n        native_test_task: ${{ fromJson(needs.build_matrix.outputs.matrix).native_test_task }}\n    env:\n      GRADLE_ENTERPRISE_ACCESS_KEY: ${{ secrets.GRADLE_ENTERPRISE_ACCESS_KEY }}\n      GRADLE_ENTERPRISE_CACHE_USERNAME: ${{ secrets.GRADLE_ENTERPRISE_CACHE_USERNAME }}\n      GRADLE_ENTERPRISE_CACHE_PASSWORD: ${{ secrets.GRADLE_ENTERPRISE_CACHE_PASSWORD }}\n    steps:\n      - uses: actions/checkout@v4\n      - name: Pre-Build Steps\n        uses: micronaut-projects/github-actions/graalvm/pre-build@master\n        id: pre-build\n        with:\n          distribution: 'graalvm'\n          java: ${{ matrix.java }}\n      - name: Build Steps\n        uses: micronaut-projects/github-actions/graalvm/build@master\n        id: build\n        env:\n          GH_TOKEN_PUBLIC_REPOS_READONLY: ${{ secrets.GH_TOKEN_PUBLIC_REPOS_READONLY }}\n          GH_USERNAME: ${{ secrets.GH_USERNAME }}\n          GRAALVM_QUICK_BUILD: true\n        with:\n          nativeTestTask: ${{ matrix.native_test_task }}\n      - name: Post-Build Steps\n        uses: micronaut-projects/github-actions/graalvm/post-build@master\n        id: post-build\n        with:\n          java: ${{ matrix.java }}\n",
    "readme": "# Micronaut Framework\n\n[![Build Status](https://github.com/micronaut-projects/micronaut-core/workflows/Java%20CI/badge.svg)](https://github.com/micronaut-projects/micronaut-core/actions)\n[![Revved up by Develocity](https://img.shields.io/badge/Revved%20up%20by-Develocity-06A0CE?logo=Gradle&labelColor=02303A)](https://ge.micronaut.io/scans)\n[![Quality Gate Status](https://sonarcloud.io/api/project_badges/measure?project=micronaut-projects_micronaut-core&metric=alert_status)](https://sonarcloud.io/summary/new_code?id=micronaut-projects_micronaut-core)\n\n[Micronaut Framework](https://micronaut.io) is a modern, JVM-based, full stack Java framework designed for building modular, easily testable JVM applications with support for Java, Kotlin and the Groovy language.\n\nThe Micronaut framework was originally created by a team who had also worked on the Grails framework. The Micronaut framework takes inspiration from lessons learned over the years building real-world applications from monoliths to microservices using Spring, Spring Boot and the Grails framework. The core team continues to develop and maintain the Micronaut project through the support of the Micronaut Foundation.\n\nMicronaut Framework aims to provide all the tools necessary to build JVM applications including:\n\n* Dependency Injection and Inversion of Control (IoC)\n* Aspect Oriented Programming (AOP)\n* Sensible Defaults and Auto-Configuration\n\nWith Micronaut Framework you can build Message-Driven Applications, Command Line Applications, HTTP Servers and more whilst for Microservices in particular Micronaut Framework also provides:\n\n* Distributed Configuration\n* Service Discovery\n* HTTP Routing\n* Client-Side Load Balancing\n\nAt the same time Micronaut Framework aims to avoid the downsides of frameworks like Spring, Spring Boot and Grails by providing:\n\n* Fast startup time\n* Reduced memory footprint\n* Minimal use of reflection\n* Minimal use of proxies\n* No runtime bytecode generation\n* Easy Unit Testing\n\nThis is achieved by pre-computing the framework infrastructure at compilation time which reduces the logic required at runtime for the application to work.\n\nFor more information on using Micronaut Framework see the documentation at [micronaut.io](https://micronaut.io)\n\n## Example Applications\n\nExample Micronaut Framework applications can be found in the [Examples repository](https://github.com/micronaut-projects/micronaut-examples)\n\n## Building From Source\n\nTo build from source checkout the code and run:\n\n```\n./gradlew publishToMavenLocal\n```\n\nTo build the documentation run `./gradlew docs`. The documentation is built to `build/docs/index.html`.\n\n## Contributing Code\n\nIf you wish to contribute to the development of Micronaut Framework please read the [CONTRIBUTING.md](CONTRIBUTING.md)\n\n## Versioning\n\nMicronaut Framework uses Semantic Versioning 2.0.0. To understand what that means, please see the specification [documentation](https://semver.org/). Exclusions to Micronaut Framework's public API include any classes annotated with `@Experimental` or `@Internal`, which reside in the `io.micronaut.core.annotation` package.\n"
}