##### LLM INPUT #####
================================ System Message ================================

You are a developer. Your task is to verify whether the environment for the given project is set up correctly. Your colleague has set up a Docker environment for the project. You need to verify if it can successfully run the tests of the project.
- You interact with a Bash session inside this container.
- The container is based on ubuntu:22.04.
- The setup commands that your colleague has run are ['apt-get update && apt-get install -y build-essential gfortran', 'make BINARY=64']
- Project files are located in /testbed within the container, and your current working directory of bash is already set to /testbed.
- Use the same test framework as your colleague, because that aligns with the setup stage.
- Only test commands, skip linting/packaging/publishing commands.
- Do not change the state of the environment, your task is to verify not to fix it. If you see issues, report it not fix it.
- You can tolerate a few test cases failures—as long as most tests pass, it's good enough. ## Important Note:

Your test command must output detailed pass/fail status for each test item. This is mandatory. For example, with pytest, use the -rA option to get output like:
```
...
PASSED tests/test_resources.py::test_fetch_centromeres
PASSED tests/test_vis.py::test_to_ucsc_colorstring
```
Since we need to parse the test output to extract a test item → status mapping, **this requirement is mandatory**. If you observed that your test command does not produce such detailed output, you must adjust it accordingly.

In summary, your goal is:
1. Write the test commands that could output detailed pass/fail status for each test item, you can iterate until it does. (this is mandatory, DO NOT ignore this requirement!!! This is your obligation to correctly identify the test commands to run the test suite of the project, and find a way to output detailed pass/fail status)
2. Run the test command to verify if the environment is set up correctly. If not, report any observed issues. If you think the setup is correct, report none issue.

================================ Human Message =================================


You run in a loop of Thought, Action, Observation.
At the end of the loop you should use Action to stop the loop.

Use Thought to describe your thoughts about the question you have been asked.
Use Action to run one of the actions available to you.
Observation will be the result of running those actions.
> Important Note: Each step, reply with only **one** (Thought, Action) pair.
> Important Note: Do not reply **Observation**, it will be provided by the system.

Your available actions are:

    Command: run a command in the bash, reply with following format, your command should not require sudo or interactive input:
        <command>...</command>
        e.g. run pytest with detailed output turned on: <command>pytest -rA</command>
        e.g. <command>tox -- -rA</command>
    Issue: stop the verify loop once you think the setup is complete, and reply with the issue of the setup:
        <issue>...</issue>
        e.g. <issue>some dependency is missing, run `pytest` failed</issue>
        e.g. <issue>None</issue> if you think the setup is correct (remember to tolerate a few test cases failures as long as most tests pass)
    

Observation will be the result of running those actions.


Project Structure: the structure of the project, including files and directories.
Related Files: the content of related files of the project that may help you understand the project.
Thought: you should always think about what to do
Action: <command>your bash command here</command> or <search>your search query</search> or other actions available
Observation: the result of the action
... (this Thought/Action/Observation can repeat N times) ...
Thought: I think the setup should be fine
Action: <stop>stop the setup</stop>
Answer: the final result

Begin!
Project Structure: 📂 
/home/hagon/Project/msb/EnvAgent/git/EnvBench/baseline_RepoLaunch/SWE-bench-Live/launch/
playground/EnvPilot_baseline/OpenMathLib__OpenBLAS-4729/repo
┣━━ 📂 .github
┣━━ 📂 benchmark
┣━━ 📂 cmake
┣━━ 📂 cpp_thread_test
┣━━ 📂 ctest
┣━━ 📂 docs
┣━━ 📂 driver
┣━━ 📂 exports
┣━━ 📂 interface
┣━━ 📂 kernel
┣━━ 📂 lapack
┣━━ 📂 lapack-netlib
┣━━ 📂 reference
┣━━ 📂 relapack
┣━━ 📂 test
┣━━ 📂 utest
┣━━ 📄 .cirrus.yml
┣━━ 📄 .cirun.yml
┣━━ 📄 .drone.yml
┣━━ 📄 .travis.yml
┣━━ 📄 appveyor.yml
┣━━ 📄 azure-pipelines.yml
┣━━ 📄 BACKERS.md
┣━━ 📄 c_check
┣━━ 📄 c_check.pl
┣━━ 📄 cblas.h
┣━━ 📄 Changelog.txt
┣━━ 📄 CMakeLists.txt
┣━━ 📄 common.h
┣━━ 📄 common_alpha.h
┣━━ 📄 common_arm.h
┣━━ 📄 common_arm64.h
┣━━ 📄 common_c.h
┣━━ 📄 common_csky.h
┣━━ 📄 common_d.h
┣━━ 📄 common_e2k.h
┣━━ 📄 common_ia64.h
┣━━ 📄 common_interface.h
┣━━ 📄 common_lapack.h
┣━━ 📄 common_level1.h
┣━━ 📄 common_level2.h
┣━━ 📄 common_level3.h
┣━━ 📄 common_linux.h
┣━━ 📄 common_loongarch64.h
┣━━ 📄 common_macro.h
┣━━ 📄 common_mips.h
┣━━ 📄 common_mips64.h
┣━━ 📄 common_param.h
┣━━ 📄 common_power.h
┣━━ 📄 common_q.h
┣━━ 📄 common_reference.h
┣━━ 📄 common_riscv64.h
┣━━ 📄 common_s.h
┣━━ 📄 common_sb.h
┣━━ 📄 common_sparc.h
┣━━ 📄 common_stackalloc.h
┣━━ 📄 common_thread.h
┣━━ 📄 common_x.h
┣━━ 📄 common_x86.h
┣━━ 📄 common_x86_64.h
┣━━ 📄 common_z.h
┣━━ 📄 common_zarch.h
┣━━ 📄 CONTRIBUTORS.md
┣━━ 📄 cpuid.h
┣━━ 📄 cpuid.S
┣━━ 📄 cpuid_alpha.c
┣━━ 📄 cpuid_arm.c
┣━━ 📄 cpuid_arm64.c
┣━━ 📄 cpuid_ia64.c
┣━━ 📄 cpuid_loongarch64.c
┣━━ 📄 cpuid_mips.c
┣━━ 📄 cpuid_mips64.c
┣━━ 📄 cpuid_power.c
┣━━ 📄 cpuid_riscv64.c
┣━━ 📄 cpuid_sparc.c
┣━━ 📄 cpuid_x86.c
┣━━ 📄 cpuid_zarch.c
┣━━ 📄 cpuid_zarch.h
┣━━ 📄 ctest.c
┣━━ 📄 ctest1.c
┣━━ 📄 ctest2.c
┣━━ 📄 f_check
┣━━ 📄 f_check.pl
┣━━ 📄 ftest.f
┣━━ 📄 ftest2.f
┣━━ 📄 ftest3.f
┣━━ 📄 gen_config_h.c
┣━━ 📄 getarch.c
┣━━ 📄 getarch_2nd.c
┣━━ 📄 GotoBLAS_00License.txt
┣━━ 📄 GotoBLAS_01Readme.txt
┣━━ 📄 GotoBLAS_02QuickInstall.txt
┣━━ 📄 GotoBLAS_03FAQ.txt
┣━━ 📄 GotoBLAS_04FAQ.txt
┣━━ 📄 GotoBLAS_05LargePage.txt
┣━━ 📄 GotoBLAS_06WeirdPerformance.txt
┣━━ 📄 Jenkinsfile
┣━━ 📄 Jenkinsfile.pwr
┣━━ 📄 l1param.h
┣━━ 📄 l2param.h
┣━━ 📄 LICENSE
┣━━ 📄 make.inc
┣━━ 📄 Makefile
┣━━ 📄 Makefile.alpha
┣━━ 📄 Makefile.arm
┣━━ 📄 Makefile.arm64
┣━━ 📄 Makefile.csky
┣━━ 📄 Makefile.e2k
┣━━ 📄 Makefile.generic
┣━━ 📄 Makefile.ia64
┣━━ 📄 Makefile.install
┣━━ 📄 Makefile.loongarch64
┣━━ 📄 Makefile.mips
┣━━ 📄 Makefile.mips64
┣━━ 📄 Makefile.power
┣━━ 📄 Makefile.prebuild
┣━━ 📄 Makefile.riscv64
┣━━ 📄 Makefile.rule
┣━━ 📄 Makefile.sparc
┣━━ 📄 Makefile.system
┣━━ 📄 Makefile.tail
┣━━ 📄 Makefile.x86
┣━━ 📄 Makefile.x86_64
┣━━ 📄 Makefile.zarch
┣━━ 📄 mkdocs.yml
┣━━ 📄 openblas.pc.in
┣━━ 📄 openblas_config_template.h
┣━━ 📄 param.h
┣━━ 📄 quickbuild.32bit
┣━━ 📄 quickbuild.64bit
┣━━ 📄 quickbuild.win32
┣━━ 📄 quickbuild.win64
┣━━ 📄 README.md
┣━━ 📄 SECURITY.md
┣━━ 📄 segfaults.patch
┣━━ 📄 symcopy.h
┣━━ 📄 TargetList.txt
┣━━ 📄 USAGE.md
┗━━ 📄 version.h

Related Files: ------ BEGIN RELATED FILES ------
File: quickbuild.64bit
```
#!/bin/bash

make BINARY=64

```
File: README.md
```
# OpenBLAS

[![Join the chat at https://gitter.im/xianyi/OpenBLAS](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/xianyi/OpenBLAS?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)

Travis CI: [![Build Status](https://travis-ci.com/xianyi/OpenBLAS.svg?branch=develop)](https://travis-ci.com/xianyi/OpenBLAS)

AppVeyor: [![Build status](https://ci.appveyor.com/api/projects/status/09sohd35n8nkkx64/branch/develop?svg=true)](https://ci.appveyor.com/project/xianyi/openblas/branch/develop)

Cirrus CI: [![Build Status](https://api.cirrus-ci.com/github/xianyi/OpenBLAS.svg?branch=develop)](https://cirrus-ci.com/github/xianyi/OpenBLAS)
<!-- Drone CI: [![Build Status](https://cloud.drone.io/api/badges/xianyi/OpenBLAS/status.svg?branch=develop)](https://cloud.drone.io/xianyi/OpenBLAS/)-->


[![Build Status](https://dev.azure.com/xianyi/OpenBLAS/_apis/build/status/xianyi.OpenBLAS?branchName=develop)](https://dev.azure.com/xianyi/OpenBLAS/_build/latest?definitionId=1&branchName=develop)

OSUOSL POWERCI [![Build Status](https://powerci.osuosl.org/buildStatus/icon?job=OpenBLAS_gh%2Fdevelop)](http://powerci.osuosl.org/job/OpenBLAS_gh/job/develop/)

OSUOSL IBMZ-CI [![Build Status](http://ibmz-ci.osuosl.org/buildStatus/icon?job=OpenBLAS-Z%2Fdevelop)](http://ibmz-ci.osuosl.org/job/OpenBLAS-Z/job/develop/)
## Introduction

OpenBLAS is an optimized BLAS (Basic Linear Algebra Subprograms) library based on GotoBLAS2 1.13 BSD version.

Please read the documentation on the OpenBLAS wiki pages: <https://github.com/xianyi/OpenBLAS/wiki>.

For a general introduction to the BLAS routines, please refer to the extensive documentation of their reference implementation hosted at netlib:
<https://www.netlib.org/blas>. On that site you will likewise find documentation for the reference implementation of the higher-level library LAPACK - the **L**inear **A**lgebra **Pack**age that comes included with OpenBLAS. If you are looking for a general primer or refresher on Linear Algebra, the set of six
20-minute lecture videos by Prof. Gilbert Strang on either MIT OpenCourseWare <https://ocw.mit.edu/resources/res-18-010-a-2020-vision-of-linear-algebra-spring-2020/> or Youtube <https://www.youtube.com/playlist?list=PLUl4u3cNGP61iQEFiWLE21EJCxwmWvvek> may be helpful.

## Binary Packages

We provide official binary packages for the following platform:

  * Windows x86/x86_64

You can download them from [file hosting on sourceforge.net](https://sourceforge.net/projects/openblas/files/) or from the Releases section of the github project page, [https://github.com/xianyi/OpenBLAS/releases](https://github.com/xianyi/OpenBLAS/releases).

## Installation from Source

Download from project homepage, https://xianyi.github.com/OpenBLAS/, or check out the code
using Git from https://github.com/xianyi/OpenBLAS.git. (If you want the most up to date version, be
sure to use the develop branch - master is several years out of date due to a change of maintainership.)
Buildtime parameters can be chosen in Makefile.rule, see there for a short description of each option.
Most can also be given directly on the make or cmake command line.

### Dependencies

Building OpenBLAS requires the following to be installed:

* GNU Make
* A C compiler, e.g. GCC or Clang
* A Fortran compiler (optional, for LAPACK)
* IBM MASS (optional, see below)

### Normal compile

Simply invoking `make` (or `gmake` on BSD) will detect the CPU automatically.
To set a specific target CPU, use `make TARGET=xxx`, e.g. `make TARGET=NEHALEM`.
The full target list is in the file `TargetList.txt`, other build optionss are documented in Makefile.rule and
can either be set there (typically by removing the comment character from the respective line), or used on the
`make` command line. 
Note that when you run `make install` after building, you need to repeat all command line options you provided to `make`
in the build step, as some settings like the supported maximum number of threads are automatically derived from the
build host by default, which might not be what you want.
For building with `cmake`, the usual conventions apply, i.e. create a build directory either underneath the toplevel
OpenBLAS source directory or separate from it, and invoke `cmake` there with the path to the source tree and any 
build options you plan to set.

### Cross compile

Set `CC` and `FC` to point to the cross toolchains, and set `HOSTCC` to your host C compiler.
The target must be specified explicitly when cross compiling.

Examples:

* On an x86 box, compile this library for a loongson3a CPU:
  ```sh
  make BINARY=64 CC=mips64el-unknown-linux-gnu-gcc FC=mips64el-unknown-linux-gnu-gfortran HOSTCC=gcc TARGET=LOONGSON3A
  ```
  or same with the newer mips-crosscompiler put out by Loongson that defaults to the 32bit ABI:
  ```sh
  make HOSTCC=gcc CC='/opt/mips-loongson-gcc7.3-linux-gnu/2019.06-29/bin/mips-linux-gnu-gcc -mabi=64' FC='/opt/mips-loongson-gcc7.3-linux-gnu/2019.06-29/bin/mips-linux-gnu-gfortran -mabi=64' TARGET=LOONGSON3A
  ```

* On an x86 box, compile this library for a loongson3a CPU with loongcc (based on Open64) compiler:
  ```sh
  make CC=loongcc FC=loongf95 HOSTCC=gcc TARGET=LOONGSON3A CROSS=1 CROSS_SUFFIX=mips64el-st-linux-gnu-   NO_LAPACKE=1 NO_SHARED=1 BINARY=32
  ```

### Debug version

A debug version can be built using `make DEBUG=1`.

### Compile with MASS support on Power CPU (optional)

The [IBM MASS](https://www.ibm.com/support/home/product/W511326D80541V01/other_software/mathematical_acceleration_subsystem) library consists of a set of mathematical functions for C, C++, and Fortran applications that are tuned for optimum performance on POWER architectures.
OpenBLAS with MASS requires a 64-bit, little-endian OS on POWER.
The library can be installed as shown:

* On Ubuntu:
  ```sh
  wget -q http://public.dhe.ibm.com/software/server/POWER/Linux/xl-compiler/eval/ppc64le/ubuntu/public.gpg -O- | sudo apt-key add -
  echo "deb http://public.dhe.ibm.com/software/server/POWER/Linux/xl-compiler/eval/ppc64le/ubuntu/ trusty main" | sudo tee /etc/apt/sources.list.d/ibm-xl-compiler-eval.list
  sudo apt-get update
  sudo apt-get install libxlmass-devel.8.1.5
  ```

* On RHEL/CentOS:
  ```sh
  wget http://public.dhe.ibm.com/software/server/POWER/Linux/xl-compiler/eval/ppc64le/rhel7/repodata/repomd.xml.key
  sudo rpm --import repomd.xml.key
  wget http://public.dhe.ibm.com/software/server/POWER/Linux/xl-compiler/eval/ppc64le/rhel7/ibm-xl-compiler-eval.repo
  sudo cp ibm-xl-compiler-eval.repo /etc/yum.repos.d/
  sudo yum install libxlmass-devel.8.1.5
  ```

After installing the MASS library, compile OpenBLAS with `USE_MASS=1`.
For example, to compile on Power8 with MASS support: `make USE_MASS=1 TARGET=POWER8`.

### Install to a specific directory (optional)

Use `PREFIX=` when invoking `make`, for example

```sh
make install PREFIX=your_installation_directory
```
(along with all options you added on the `make` command line in the preceding build step)
The default installation directory is `/opt/OpenBLAS`.

## Supported CPUs and Operating Systems

Please read `GotoBLAS_01Readme.txt` for older CPU models already supported by the 2010 GotoBLAS.

### Additional supported CPUs

#### x86/x86-64

- **Intel Xeon 56xx (Westmere)**: Used GotoBLAS2 Nehalem codes.
- **Intel Sandy Bridge**: Optimized Level-3 and Level-2 BLAS with AVX on x86-64.
- **Intel Haswell**: Optimized Level-3 and Level-2 BLAS with AVX2 and FMA on x86-64.
- **Intel Skylake-X**: Optimized Level-3 and Level-2 BLAS with AVX512 and FMA on x86-64.
- **Intel Cooper Lake**: as Skylake-X with improved BFLOAT16 support.
- **AMD Bobcat**: Used GotoBLAS2 Barcelona codes.
- **AMD Bulldozer**: x86-64 ?GEMM FMA4 kernels. (Thanks to Werner Saar)
- **AMD PILEDRIVER**: Uses Bulldozer codes with some optimizations.
- **AMD STEAMROLLER**: Uses Bulldozer codes with some optimizations.
- **AMD ZEN**: Uses Haswell codes with some optimizations for Zen 2/3 (use SkylakeX for Zen4)

#### MIPS32

- **MIPS 1004K**: uses P5600 codes
- **MIPS 24K**: uses P5600 codes

#### MIPS64

- **ICT Loongson 3A**: Optimized Level-3 BLAS and the part of Level-1,2.
- **ICT Loongson 3B**: Experimental

#### ARM

- **ARMv6**: Optimized BLAS for vfpv2 and vfpv3-d16 (e.g. BCM2835, Cortex M0+)
- **ARMv7**: Optimized BLAS for vfpv3-d32 (e.g. Cortex A8, A9 and A15)

#### ARM64

- **ARMv8**: Basic ARMV8 with small caches, optimized Level-3 and Level-2 BLAS
- **Cortex-A53**: same as ARMV8 (different cpu specifications)
- **Cortex-A55**: same as ARMV8 (different cpu specifications)
- **Cortex A57**: Optimized Level-3 and Level-2 functions
- **Cortex A72**: same as A57 ( different cpu specifications)
- **Cortex A73**: same as A57 (different cpu specifications)
- **Cortex A76**: same as A57 (different cpu specifications)
- **Falkor**: same as A57 (different cpu specifications)
- **ThunderX**: Optimized some Level-1 functions
- **ThunderX2T99**: Optimized Level-3 BLAS and parts of Levels 1 and 2
- **ThunderX3T110**
- **TSV110**: Optimized some Level-3 helper functions
- **EMAG 8180**: preliminary support based on A57
- **Neoverse N1**: (AWS Graviton2) preliminary support
- **Neoverse V1**: (AWS Graviton3) optimized Level-3 BLAS
- **Apple Vortex**: preliminary support based on ThunderX2/3
- **A64FX**:  preliminary support, optimized Level-3 BLAS
- **ARMV8SVE**: any ARMV8 cpu with SVE extensions 

#### PPC/PPC64

- **POWER8**: Optimized BLAS, only for PPC64LE (Little Endian), only with `USE_OPENMP=1`
- **POWER9**: Optimized Level-3 BLAS (real) and some Level-1,2. PPC64LE with OpenMP only. 
- **POWER10**: Optimized Level-3 BLAS including SBGEMM and some Level-1,2.

- **AIX**: Dynamic architecture with OpenXL and OpenMP.
  ```sh
  make CC=ibm-clang_r FC=xlf_r TARGET=POWER7 BINARY=64 USE_OPENMP=1 INTERFACE64=1 DYNAMIC_ARCH=1 USE_THREAD=1
  ```

#### IBM zEnterprise System

- **Z13**: Optimized Level-3 BLAS and Level-1,2
- **Z14**: Optimized Level-3 BLAS and (single precision) Level-1,2

#### RISC-V

- **C910V**: Optimized Level-3 BLAS (real) and Level-1,2 by RISC-V Vector extension 0.7.1.
  ```sh
  make HOSTCC=gcc TARGET=C910V CC=riscv64-unknown-linux-gnu-gcc FC=riscv64-unknown-linux-gnu-gfortran
  ```
  (also known to work on C906 as long as you use only single-precision functions - its instruction set support appears to be incomplete in double precision)

- **x280**: Level-3 BLAS and Level-1,2 are optimized by RISC-V Vector extension 1.0.
  ```sh
  make HOSTCC=gcc TARGET=x280 NUM_THREADS=8 CC=riscv64-unknown-linux-gnu-clang FC=riscv64-unknown-linux-gnu-gfortran
  ```

- **ZVL???B**: Level-3 BLAS and Level-1,2 including vectorised kernels targeting generic RISCV cores with vector support with registers of at least the corresponding width; ZVL128B and ZVL256B are available.
e.g.:
  ```sh
    make TARGET=RISCV64_ZVL256B CFLAGS="-DTARGET=RISCV64_ZVL256B" \
    BINARY=64 ARCH=riscv64 CC='clang -target riscv64-unknown-linux-gnu' \
    AR=riscv64-unknown-linux-gnu-ar AS=riscv64-unknown-linux-gnu-gcc \
    LD=riscv64-unknown-linux-gnu-gcc FC=riscv64-unknown-linux-gnu-gfortran \
    HOSTCC=gcc HOSTFC=gfortran -j
  ```

### Support for multiple targets in a single library

OpenBLAS can be built for multiple targets with runtime detection of the target cpu by specifiying `DYNAMIC_ARCH=1` in Makefile.rule, on the gmake command line or as `-DDYNAMIC_ARCH=TRUE` in cmake.

For **x86_64**, the list of targets this activates contains Prescott, Core2, Nehalem, Barcelona, Sandybridge, Bulldozer, Piledriver, Steamroller, Excavator, Haswell, Zen, SkylakeX, Cooper Lake, Sapphire Rapids. For cpu generations not included in this list, the corresponding older model is used. If you also specify `DYNAMIC_OLDER=1`, specific support for Penryn, Dunnington, Opteron, Opteron/SSE3, Bobcat, Atom and Nano is added. Finally there is an option `DYNAMIC_LIST` that allows to specify an individual list of targets to include instead of the default.

`DYNAMIC_ARCH` is also supported on **x86**, where it translates to Katmai, Coppermine, Northwood, Prescott, Banias,
Core2, Penryn, Dunnington, Nehalem, Athlon, Opteron, Opteron_SSE3, Barcelona, Bobcat, Atom and Nano.

On **ARMV8**, it enables support for CortexA53, CortexA57, CortexA72, CortexA73, Falkor, ThunderX, ThunderX2T99, TSV110 as well as generic ARMV8 cpus. If compiler support for SVE is available at build time, support for NeoverseN2, NeoverseV1 as well as generic ArmV8SVE targets is also enabled.

For **POWER**, the list encompasses POWER6, POWER8 and POWER9. POWER10 is additionally available if a sufficiently recent compiler is used for the build.

on **ZARCH** it comprises Z13 and Z14 as well as generic zarch support.

The `TARGET` option can be used in conjunction with `DYNAMIC_ARCH=1` to specify which cpu model should be assumed for all the
common code in the library, usually you will want to set this to the oldest model you expect to encounter.
Please note that it is not possible to combine support for different architectures, so no combined 32 and 64 bit or x86_64 and arm64 in the same library.

### Supported OS

- **GNU/Linux**
- **MinGW or Visual Studio (CMake)/Windows**: Please read <https://github.com/xianyi/OpenBLAS/wiki/How-to-use-OpenBLAS-in-Microsoft-Visual-Studio>.
- **Darwin/macOS/OSX/iOS**: Experimental. Although GotoBLAS2 already supports Darwin, we are not OSX/iOS experts.
- **FreeBSD**: Supported by the community. We don't actively test the library on this OS.
- **OpenBSD**: Supported by the community. We don't actively test the library on this OS.
- **NetBSD**: Supported by the community. We don't actively test the library on this OS.
- **DragonFly BSD**: Supported by the community. We don't actively test the library on this OS.
- **Android**: Supported by the community. Please read <https://github.com/xianyi/OpenBLAS/wiki/How-to-build-OpenBLAS-for-Android>.
- **AIX**: Supported on PPC up to POWER10
- **Haiku**: Supported by the community. We don't actively test the library on this OS.
- **SunOS**: Supported by the community. We don't actively test the library on this OS.
- **Cortex-M**: Supported by the community. Please read <https://github.com/xianyi/OpenBLAS/wiki/How-to-use-OpenBLAS-on-Cortex-M>.

## Usage

Statically link with `libopenblas.a` or dynamically link with `-lopenblas` if OpenBLAS was
compiled as a shared library.

### Setting the number of threads using environment variables

Environment variables are used to specify a maximum number of threads.
For example,

```sh
export OPENBLAS_NUM_THREADS=4
export GOTO_NUM_THREADS=4
export OMP_NUM_THREADS=4
```

The priorities are `OPENBLAS_NUM_THREADS` > `GOTO_NUM_THREADS` > `OMP_NUM_THREADS`.

If you compile this library with `USE_OPENMP=1`, you should set the `OMP_NUM_THREADS`
environment variable; OpenBLAS ignores `OPENBLAS_NUM_THREADS` and `GOTO_NUM_THREADS` when
compiled with `USE_OPENMP=1`.

### Setting the number of threads at runtime

We provide the following functions to control the number of threads at runtime:

```c
void goto_set_num_threads(int num_threads);
void openblas_set_num_threads(int num_threads);
```
Note that these are only used once at library initialization, and are not available for
fine-tuning thread numbers in individual BLAS calls. 
If you compile this library with `USE_OPENMP=1`, you should use the above functions too.

## Reporting bugs

Please submit an issue in https://github.com/xianyi/OpenBLAS/issues.

## Contact

* OpenBLAS users mailing list: https://groups.google.com/forum/#!forum/openblas-users
* OpenBLAS developers mailing list: https://groups.google.com/forum/#!forum/openblas-dev

## Change log

Please see Changelog.txt to view the differences between OpenBLAS and GotoBLAS2 1.13 BSD version.

## Troubleshooting

* Please read the [FAQ](https://github.com/xianyi/OpenBLAS/wiki/Faq) first.
* Please use GCC version 4.6 and above to compile Sandy Bridge AVX kernels on Linux/MinGW/BSD.
* Please use Clang version 3.1 and above to compile the library on Sandy Bridge microarchitecture.
  Clang 3.0 will generate the wrong AVX binary code.
* Please use GCC version 6 or LLVM version 6 and above to compile Skylake AVX512 kernels.
* The number of CPUs/cores should be less than or equal to 256. On Linux `x86_64` (`amd64`),
  there is experimental support for up to 1024 CPUs/cores and 128 numa nodes if you build
  the library with `BIGNUMA=1`.
* OpenBLAS does not set processor affinity by default.
  On Linux, you can enable processor affinity by commenting out the line `NO_AFFINITY=1` in
  Makefile.rule. However, note that this may cause
  [a conflict with R parallel](https://stat.ethz.ch/pipermail/r-sig-hpc/2012-April/001348.html).
* On Loongson 3A, `make test` may fail with a `pthread_create` error (`EAGAIN`).
  However, it will be okay when you run the same test case on the shell.

## Contributing

1. [Check for open issues](https://github.com/xianyi/OpenBLAS/issues) or open a fresh issue
   to start a discussion around a feature idea or a bug.
2. Fork the [OpenBLAS](https://github.com/xianyi/OpenBLAS) repository to start making your changes.
3. Write a test which shows that the bug was fixed or that the feature works as expected.
4. Send a pull request. Make sure to add yourself to `CONTRIBUTORS.md`.

## Donation

Please read [this wiki page](https://github.com/xianyi/OpenBLAS/wiki/Donation).

```
File: Makefile.system
```
#
# Include user definition
#

# TO suppress recursive includes
INCLUDED = 1

ifndef TOPDIR
TOPDIR = . 
endif

ifndef RELAPACK_REPLACE
RELAPACK_REPLACE=0
endif

# we need to use the host system's architecture for getarch compile options even especially when cross-compiling
HOSTARCH := $(shell uname -m)
ifeq ($(HOSTARCH), amd64)
HOSTARCH=x86_64
endif

# Catch conflicting usage of ARCH in some BSD environments
ifeq ($(ARCH), amd64)
override ARCH=x86_64
else ifeq ($(ARCH), powerpc64)
override ARCH=power
else ifeq ($(ARCH), powerpc64le)
override ARCH=power
else ifeq ($(ARCH), powerpc)
override ARCH=power
else ifeq ($(ARCH), i386)
override ARCH=x86
else ifeq ($(ARCH), armv6)
override ARCH=arm
else ifeq ($(ARCH), armv7)
override ARCH=arm
else ifeq ($(ARCH), aarch64)
override ARCH=arm64
else ifeq ($(ARCH), mipsel)
override ARCH=mips
else ifeq ($(ARCH), mips64el)
override ARCH=mips64
else ifeq ($(ARCH), zarch)
override ARCH=zarch
endif

NETLIB_LAPACK_DIR = $(TOPDIR)/lapack-netlib

# Default C compiler
# - Only set if not specified on the command line or inherited from the environment.
# - CC is an implicit variable so neither '?=' or 'ifndef' can be used.
#   http://stackoverflow.com/questions/4029274/mingw-and-make-variables
# - Default value is 'cc' which is not always a valid command (e.g. MinGW).
ifeq ($(origin CC),default)

# Check if $(CC) refers to a valid command and set the value to gcc if not
ifneq ($(findstring cmd.exe,$(SHELL)),)
ifeq ($(shell where $(CC) 2>NUL),)
CC = gcc
endif
else # POSIX-ish
ifeq ($(shell command -v $(CC) 2>/dev/null),)
ifeq ($(shell uname -s),Darwin)
CC = clang
# EXTRALIB += -Wl,-no_compact_unwind
else
CC = gcc
endif # Darwin
endif # CC exists
endif # Shell is sane

endif # CC is set to default

# Default Fortran compiler (FC) is selected by f_check.

ifndef MAKEFILE_RULE
include $(TOPDIR)/Makefile.rule
else
include $(TOPDIR)/$(MAKEFILE_RULE)
endif

#
#  Beginning of system configuration
#
ifneq ($(BUILD_SINGLE),1)
ifneq ($(BUILD_DOUBLE),1)
ifneq ($(BUILD_COMPLEX),1)
ifneq ($(BUILD_COMPLEX16),1)
override BUILD_SINGLE=1
override BUILD_DOUBLE=1
override BUILD_COMPLEX=1
override BUILD_COMPLEX16=1
endif
endif
endif
endif

ifndef HOSTCC
HOSTCC	 = $(CC)
endif

ifdef TARGET
GETARCH_FLAGS := -DFORCE_$(TARGET)
GETARCH_FLAGS += -DUSER_TARGET
ifeq ($(TARGET), GENERIC)
ifeq ($(DYNAMIC_ARCH), 1)
override NO_EXPRECISION=1
export NO_EXPRECISION
endif
endif
endif

# Force fallbacks for 32bit

ifeq ($(BINARY), 32)
ifeq ($(TARGET), HASWELL)
GETARCH_FLAGS := -DFORCE_NEHALEM
endif
ifeq ($(TARGET), SKYLAKEX)
GETARCH_FLAGS := -DFORCE_NEHALEM
endif
ifeq ($(TARGET), COOPERLAKE)
GETARCH_FLAGS := -DFORCE_NEHALEM
endif
ifeq ($(TARGET), SAPPHIRERAPIDS)
GETARCH_FLAGS := -DFORCE_NEHALEM
endif
ifeq ($(TARGET), SANDYBRIDGE)
GETARCH_FLAGS := -DFORCE_NEHALEM
endif
ifeq ($(TARGET), BULLDOZER)
GETARCH_FLAGS := -DFORCE_BARCELONA
endif
ifeq ($(TARGET), PILEDRIVER)
GETARCH_FLAGS := -DFORCE_BARCELONA
endif
ifeq ($(TARGET), STEAMROLLER)
GETARCH_FLAGS := -DFORCE_BARCELONA
endif
ifeq ($(TARGET), EXCAVATOR)
GETARCH_FLAGS := -DFORCE_BARCELONA
endif
ifeq ($(TARGET), ZEN)
GETARCH_FLAGS := -DFORCE_BARCELONA
endif
ifeq ($(TARGET), ARMV8)
GETARCH_FLAGS := -DFORCE_ARMV7
endif
ifeq ($(TARGET), POWER8)
GETARCH_FLAGS := -DFORCE_POWER6
endif
ifeq ($(TARGET), POWER9)
GETARCH_FLAGS := -DFORCE_POWER6
endif
ifeq ($(TARGET), POWER10)
GETARCH_FLAGS := -DFORCE_POWER6
endif
endif

#TARGET_CORE will override TARGET which is used in DYNAMIC_ARCH=1.
#
ifdef TARGET_CORE
GETARCH_FLAGS := -DFORCE_$(TARGET_CORE)
endif

# Force fallbacks for 32bit

ifeq ($(BINARY), 32)
ifeq ($(TARGET_CORE), HASWELL)
GETARCH_FLAGS := -DFORCE_NEHALEM
endif
ifeq ($(TARGET_CORE), SKYLAKEX)
GETARCH_FLAGS := -DFORCE_NEHALEM
endif
ifeq ($(TARGET_CORE), COOPERLAKE)
GETARCH_FLAGS := -DFORCE_NEHALEM
endif
ifeq ($(TARGET_CORE), SAPPHIRERAPIDS)
GETARCH_FLAGS := -DFORCE_NEHALEM
endif
ifeq ($(TARGET_CORE), SANDYBRIDGE)
GETARCH_FLAGS := -DFORCE_NEHALEM
endif
ifeq ($(TARGET_CORE), BULLDOZER)
GETARCH_FLAGS := -DFORCE_BARCELONA
endif
ifeq ($(TARGET_CORE), PILEDRIVER)
GETARCH_FLAGS := -DFORCE_BARCELONA
endif
ifeq ($(TARGET_CORE), STEAMROLLER)
GETARCH_FLAGS := -DFORCE_BARCELONA
endif
ifeq ($(TARGET_CORE), EXCAVATOR)
GETARCH_FLAGS := -DFORCE_BARCELONA
endif
ifeq ($(TARGET_CORE), ZEN)
GETARCH_FLAGS := -DFORCE_BARCELONA
endif
endif


# On x86_64 build getarch with march=native unless the compiler is PGI. This is required to detect AVX512 support in getarch.
ifeq ($(HOSTARCH), x86_64)
ifeq ($(findstring pgcc,$(HOSTCC))$(findstring nvc,$(HOSTCC)),)
GETARCH_FLAGS += -march=native
endif
endif

ifdef INTERFACE64
ifneq ($(INTERFACE64), 0)
GETARCH_FLAGS	+= -DUSE64BITINT
endif
endif

ifndef GEMM_MULTITHREAD_THRESHOLD
GEMM_MULTITHREAD_THRESHOLD=4
endif
GETARCH_FLAGS	+= -DGEMM_MULTITHREAD_THRESHOLD=$(GEMM_MULTITHREAD_THRESHOLD)

ifeq ($(NO_AVX), 1)
GETARCH_FLAGS	+= -DNO_AVX
endif

ifeq ($(BINARY), 32)
GETARCH_FLAGS	+= -DNO_AVX -DNO_AVX2 -DNO_AVX512
NO_AVX512 = 1
endif

ifeq ($(NO_AVX2), 1)
GETARCH_FLAGS	+= -DNO_AVX2
endif

ifeq ($(NO_AVX512), 1)
GETARCH_FLAGS	+= -DNO_AVX512
endif

ifeq ($(DEBUG), 1)
GETARCH_FLAGS	+= -g
endif

ifeq ($(QUIET_MAKE), 1)
MAKE += -s
endif

ifndef NO_PARALLEL_MAKE
NO_PARALLEL_MAKE=0
endif
GETARCH_FLAGS	+= -DNO_PARALLEL_MAKE=$(NO_PARALLEL_MAKE)

ifdef MAKE_NB_JOBS
GETARCH_FLAGS += -DMAKE_NB_JOBS=$(MAKE_NB_JOBS)
endif

ifeq ($(HOSTCC), loongcc)
GETARCH_FLAGS  += -static
endif

#if don't use Fortran, it will only compile CBLAS.
ifeq ($(ONLY_CBLAS), 1)
NO_LAPACK = 1
else
ONLY_CBLAS = 0
endif

#For small matrix optimization
ifeq ($(ARCH), x86_64)
SMALL_MATRIX_OPT = 1
else ifeq ($(ARCH), power)
SMALL_MATRIX_OPT = 1
BUILD_BFLOAT16 = 1
endif
ifeq ($(ARCH), loongarch64)
SMALL_MATRIX_OPT = 1
endif
ifeq ($(SMALL_MATRIX_OPT), 1)
CCOMMON_OPT += -DSMALL_MATRIX_OPT
endif

# This operation is expensive, so execution should be once.
ifndef GOTOBLAS_MAKEFILE
export GOTOBLAS_MAKEFILE = 1

# Generating Makefile.conf and config.h
DUMMY := $(shell $(MAKE) -C $(TOPDIR) -f Makefile.prebuild CC="$(CC)" FC="$(FC)" HOSTCC="$(HOSTCC)" HOST_CFLAGS="$(GETARCH_FLAGS)" CFLAGS="$(CFLAGS)" BINARY=$(BINARY) USE_OPENMP=$(USE_OPENMP) DYNAMIC_ARCH=$(DYNAMIC_ARCH) TARGET_CORE=$(TARGET_CORE) ONLY_CBLAS=$(ONLY_CBLAS) TARGET=$(TARGET) all)

endif

ifndef TARGET_CORE
-include $(TOPDIR)/Makefile.conf
else
HAVE_NEON=
HAVE_VFP=
HAVE_VFPV3=
HAVE_VFPV4=
HAVE_MMX=
HAVE_SSE=
HAVE_SSE2=
HAVE_SSE3=
HAVE_SSSE3=
HAVE_SSE4_1=
HAVE_SSE4_2=
HAVE_SSE4A=
HAVE_SSE5=
HAVE_AVX=
HAVE_AVX2=
HAVE_FMA3=
include $(TOPDIR)/Makefile_kernel.conf
endif


ifndef NUM_PARALLEL
NUM_PARALLEL = 1
endif

ifndef NUM_THREADS
NUM_THREADS = $(NUM_CORES)
endif

ifeq ($(NUM_THREADS), 1)
override USE_THREAD = 0
override USE_OPENMP = 0
endif

ifdef USE_THREAD
ifeq ($(USE_THREAD), 0)
SMP =
else
SMP = 1
endif
else
ifeq ($(NUM_THREADS), 1)
SMP =
else
SMP = 1
endif
endif

ifeq ($(SMP), 1)
USE_LOCKING = 
endif

ifndef NEED_PIC
NEED_PIC = 1
endif

ARFLAGS	=
CPP	= $(COMPILER) -E
AR	?= $(CROSS_SUFFIX)ar
AS	?= $(CROSS_SUFFIX)as
LD	?= $(CROSS_SUFFIX)ld
RANLIB	?= $(CROSS_SUFFIX)ranlib
NM	= $(CROSS_SUFFIX)nm
DLLWRAP = $(CROSS_SUFFIX)dllwrap
OBJCOPY = $(CROSS_SUFFIX)objcopy
OBJCONV = $(CROSS_SUFFIX)objconv


# When fortran support was either not detected or actively deselected, only build BLAS.
ifeq ($(NOFORTRAN), 1)
C_LAPACK = 1
override FEXTRALIB = 
ifeq ($(C_COMPILER), GCC)
CCOMMON_OPT += -Wno-error=incompatible-pointer-types
endif
endif

ifeq ($(C_COMPILER), GCC)
GCCVERSIONGTEQ4 := $(shell expr `$(CC) -dumpversion | cut -f1 -d.` \>= 4)
GCCVERSIONGT4 := $(shell expr `$(CC) -dumpversion | cut -f1 -d.` \> 4)
GCCVERSIONGT5 := $(shell expr `$(CC) -dumpversion | cut -f1 -d.` \> 5)
GCCVERSIONGTEQ7 := $(shell expr `$(CC) -dumpversion | cut -f1 -d.` \>= 7)
GCCVERSIONGTEQ8 := $(shell expr `$(CC) -dumpversion | cut -f1 -d.` \>= 8)
GCCVERSIONGTEQ9 := $(shell expr `$(CC) -dumpversion | cut -f1 -d.` \>= 9)
GCCVERSIONGTEQ10 := $(shell expr `$(CC) -dumpversion | cut -f1 -d.` \>= 10)
GCCVERSIONGTEQ11 := $(shell expr `$(CC) -dumpversion | cut -f1 -d.` \>= 11)
GCCVERSIONGTEQ12 := $(shell expr `$(CC) -dumpversion | cut -f1 -d.` \>= 12)
# Note that the behavior of -dumpversion is compile-time-configurable for
# gcc-7.x and newer. Use -dumpfullversion there
ifeq ($(GCCVERSIONGTEQ7),1)
	GCCDUMPVERSION_PARAM := -dumpfullversion
else
	GCCDUMPVERSION_PARAM := -dumpversion
endif
GCCMINORVERSIONGTEQ1 := $(shell expr `$(CC) $(GCCDUMPVERSION_PARAM) | cut -f2 -d.` \>= 1)
GCCMINORVERSIONGTEQ2 := $(shell expr `$(CC) $(GCCDUMPVERSION_PARAM) | cut -f2 -d.` \>= 2)
GCCMINORVERSIONGTEQ4 := $(shell expr `$(CC) $(GCCDUMPVERSION_PARAM) | cut -f2 -d.` \>= 4)
GCCMINORVERSIONGTEQ7 := $(shell expr `$(CC) $(GCCDUMPVERSION_PARAM) | cut -f2 -d.` \>= 7)
endif

ifeq ($(C_COMPILER), CLANG)
CLANGVERSIONGTEQ9 := $(shell expr `$(CC) -dumpversion | cut -f1 -d.` \>= 9)
CLANGVERSIONGTEQ12 := $(shell expr `$(CC) -dumpversion | cut -f1 -d.` \>= 12)
endif

#
#  OS dependent settings
#

ifeq ($(OSNAME), Darwin)
ifndef MACOSX_DEPLOYMENT_TARGET
ifeq ($(ARCH), arm64)
export MACOSX_DEPLOYMENT_TARGET=11.0
ifeq ($(C_COMPILER), GCC)
export NO_SVE = 1
endif
else
export MACOSX_DEPLOYMENT_TARGET=10.8
endif
endif
MD5SUM = md5 -r
XCVER = $(shell pkgutil --pkg-info=com.apple.pkg.Xcode |awk '/version:/ {print $2}'|cut -d: -f2|cut -f1 -d.)
ifeq (x$(XCVER)x,xx)
XCVER = $(shell pkgutil --pkg-info=com.apple.pkg.CLTools_Executables |awk '/version:/ {print $2}'|cut -d: -f2|cut -f1 -d.)
endif
ifeq (x$(XCVER), x 15)
CCOMMON_OPT += -Wl,-ld_classic
FCOMMON_OPT += -Wl,-ld_classic
endif
endif

ifneq (,$(findstring $(OSNAME), FreeBSD OpenBSD DragonFly))
MD5SUM = md5 -r
endif

ifeq ($(OSNAME), NetBSD)
MD5SUM = md5 -n
endif

ifeq ($(OSNAME), Linux)
EXTRALIB	+= -lm
NO_EXPRECISION = 1
endif

ifeq ($(OSNAME), Android)
EXTRALIB	+= -lm
endif

ifeq ($(OSNAME), AIX)
EXTRALIB	+= -lm
endif

ifeq ($(OSNAME), $(filter $(OSNAME),FreeBSD OpenBSD NetBSD DragonFly))
ifeq ($(ARCH), $(filter $(ARCH),arm arm64))
EXTRALIB	+= -lm
endif
endif

ifeq ($(OSNAME), WINNT)
NEED_PIC = 0
NO_EXPRECISION = 1

EXTRALIB        += -defaultlib:advapi32

SUFFIX  = obj
PSUFFIX = pobj
LIBSUFFIX = a

ifeq ($(C_COMPILER), CLANG)
CCOMMON_OPT	+= -DMS_ABI
endif

#Version tests for supporting specific features (MS_ABI, POWER9 intrinsics)
ifeq ($(GCCVERSIONGT4), 1)
# GCC Major version > 4
# It is compatible with MSVC ABI.
CCOMMON_OPT	+= -DMS_ABI
endif

ifeq ($(GCCVERSIONGTEQ4), 1)
ifeq ($(GCCMINORVERSIONGTEQ7), 1)
# GCC Version >=4.7
# It is compatible with MSVC ABI.
CCOMMON_OPT	+= -DMS_ABI
endif
endif

# Ensure the correct stack alignment on Win32
# http://permalink.gmane.org/gmane.comp.lib.openblas.general/97
ifeq ($(ARCH), x86)
CCOMMON_OPT += -mincoming-stack-boundary=2
FCOMMON_OPT += -mincoming-stack-boundary=2
endif

endif

ifeq ($(OSNAME), Interix)
NEED_PIC = 0
NO_EXPRECISION = 1

INTERIX_TOOL_DIR = /opt/gcc.3.3/i586-pc-interix3/bin
endif

ifeq ($(OSNAME), CYGWIN_NT)
NEED_PIC = 0
NO_EXPRECISION = 1
OS_CYGWIN_NT = 1
endif

ifneq ($(OSNAME), WINNT)
ifneq ($(OSNAME), CYGWIN_NT)
ifneq ($(OSNAME), Interix)
ifneq ($(OSNAME), Android)
ifdef SMP
EXTRALIB   += -lpthread
endif
endif
endif
endif
endif

# ifeq logical or
ifeq ($(OSNAME), $(filter $(OSNAME),WINNT CYGWIN_NT Interix))
OS_WINDOWS=1
endif

ifdef QUAD_PRECISION
CCOMMON_OPT	+= -DQUAD_PRECISION
NO_EXPRECISION = 1
endif

ifneq ($(ARCH), x86)
ifneq ($(ARCH), x86_64)
NO_EXPRECISION = 1
endif
endif

ifdef UTEST_CHECK
CCOMMON_OPT	+= -DUTEST_CHECK
SANITY_CHECK = 1
endif

ifdef SANITY_CHECK
CCOMMON_OPT	+= -DSANITY_CHECK -DREFNAME=$(*F)f$(BU)
endif

MAX_STACK_ALLOC ?= 2048
ifneq ($(MAX_STACK_ALLOC), 0)
CCOMMON_OPT	+= -DMAX_STACK_ALLOC=$(MAX_STACK_ALLOC)
endif

ifdef USE_LOCKING
ifneq ($(USE_LOCKING), 0)
CCOMMON_OPT	+= -DUSE_LOCKING
endif
endif

#
#  Architecture dependent settings
#

ifeq ($(ARCH), x86)
ifndef BINARY
NO_BINARY_MODE	= 1
endif

ifeq ($(CORE), generic)
NO_EXPRECISION = 1
endif

ifndef NO_EXPRECISION
ifeq ($(F_COMPILER), GFORTRAN)
# ifeq logical or. GCC or LSB
ifeq ($(C_COMPILER), $(filter $(C_COMPILER),GCC LSB))
EXPRECISION	= 1
CCOMMON_OPT	+= -DEXPRECISION -m128bit-long-double
FCOMMON_OPT	+= -m128bit-long-double
endif
ifeq ($(C_COMPILER), CLANG)
EXPRECISION	= 1
CCOMMON_OPT	+= -DEXPRECISION
FCOMMON_OPT	+= -m128bit-long-double
endif
endif
endif
endif

ifeq ($(ARCH), x86_64)

ifeq ($(CORE), generic)
NO_EXPRECISION = 1
endif

ifndef NO_EXPRECISION
ifeq ($(F_COMPILER), GFORTRAN)
# ifeq logical or. GCC or LSB
ifeq ($(C_COMPILER), $(filter $(C_COMPILER),GCC LSB))
EXPRECISION	= 1
CCOMMON_OPT	+= -DEXPRECISION -m128bit-long-double
FCOMMON_OPT	+= -m128bit-long-double
endif
ifeq ($(C_COMPILER), CLANG)
EXPRECISION	= 1
CCOMMON_OPT	+= -DEXPRECISION
FCOMMON_OPT	+= -m128bit-long-double
endif
endif
endif
endif

ifeq ($(C_COMPILER), INTEL)
CCOMMON_OPT    += -wd981
endif


ifeq ($(USE_OPENMP), 1)

#check
ifeq ($(USE_THREAD), 0)
$(error OpenBLAS: Cannot set both USE_OPENMP=1 and USE_THREAD=0. The USE_THREAD=0 is only for building single thread version.)
endif

# ifeq logical or. GCC or LSB
ifeq ($(C_COMPILER), $(filter $(C_COMPILER),GCC LSB))
CCOMMON_OPT    += -fopenmp
endif

ifeq ($(C_COMPILER), CLANG)
CCOMMON_OPT    += -fopenmp
ifeq ($(F_COMPILER), GFORTRAN)
FEXTRALIB := $(subst -lgomp,-lomp,$(FEXTRALIB))
endif
endif

ifeq ($(C_COMPILER), INTEL)
CCOMMON_OPT    += -fopenmp
endif

ifeq ($(C_COMPILER), PGI)
CCOMMON_OPT    += -mp
endif

ifeq ($(C_COMPILER), OPEN64)
CCOMMON_OPT    += -mp
CEXTRALIB   += -lstdc++
endif

ifeq ($(C_COMPILER), PATHSCALE)
CCOMMON_OPT    += -mp
endif
endif


ifeq ($(DYNAMIC_ARCH), 1)
ifeq ($(ARCH), x86)
DYNAMIC_CORE = KATMAI COPPERMINE NORTHWOOD PRESCOTT BANIAS \
	       CORE2 PENRYN DUNNINGTON NEHALEM ATHLON OPTERON OPTERON_SSE3 BARCELONA BOBCAT ATOM NANO
endif

ifeq ($(ARCH), x86_64)
DYNAMIC_CORE = PRESCOTT CORE2 
ifeq ($(DYNAMIC_OLDER), 1)
DYNAMIC_CORE += PENRYN DUNNINGTON 
endif
DYNAMIC_CORE += NEHALEM 
ifeq ($(DYNAMIC_OLDER), 1)
DYNAMIC_CORE += OPTERON OPTERON_SSE3 
endif
DYNAMIC_CORE += BARCELONA 
ifeq ($(DYNAMIC_OLDER), 1)
DYNAMIC_CORE += BOBCAT ATOM NANO
endif
ifneq ($(NO_AVX), 1)
DYNAMIC_CORE += SANDYBRIDGE BULLDOZER PILEDRIVER STEAMROLLER EXCAVATOR
endif
ifneq ($(NO_AVX2), 1)
DYNAMIC_CORE += HASWELL ZEN
endif
ifneq ($(NO_AVX512), 1)
ifneq ($(NO_AVX2), 1)
DYNAMIC_CORE += SKYLAKEX COOPERLAKE SAPPHIRERAPIDS
endif
endif
endif

ifdef DYNAMIC_LIST
override DYNAMIC_CORE = PRESCOTT $(DYNAMIC_LIST)
XCCOMMON_OPT = -DDYNAMIC_LIST -DDYN_PRESCOTT
XCCOMMON_OPT += $(foreach dcore,$(DYNAMIC_LIST),-DDYN_$(dcore))
CCOMMON_OPT += $(XCCOMMON_OPT)
#CCOMMON_OPT	+= -DDYNAMIC_LIST='$(DYNAMIC_LIST)'
endif

ifeq ($(ARCH), arm64)
DYNAMIC_CORE =  ARMV8
DYNAMIC_CORE += CORTEXA53
DYNAMIC_CORE += CORTEXA57
DYNAMIC_CORE += NEOVERSEN1
ifneq ($(NO_SVE), 1)
DYNAMIC_CORE += NEOVERSEV1
DYNAMIC_CORE += NEOVERSEN2
DYNAMIC_CORE += ARMV8SVE
endif
DYNAMIC_CORE += THUNDERX
DYNAMIC_CORE += THUNDERX2T99
DYNAMIC_CORE += TSV110
DYNAMIC_CORE += EMAG8180
DYNAMIC_CORE += THUNDERX3T110
ifdef DYNAMIC_LIST
override DYNAMIC_CORE = ARMV8 $(DYNAMIC_LIST)
XCCOMMON_OPT = -DDYNAMIC_LIST -DDYN_ARMV8
XCCOMMON_OPT += $(foreach dcore,$(DYNAMIC_LIST),-DDYN_$(dcore))
endif
endif

ifeq ($(ARCH), mips64)
DYNAMIC_CORE = LOONGSON3R3 LOONGSON3R4 MIPS64_GENERIC
ifdef DYNAMIC_LIST
override DYNAMIC_CORE = MIPS64_GENERIC $(DYNAMIC_LIST)
XCCOMMON_OPT = -DDYNAMIC_LIST -DDYN_MIPS64_GENERIC
XCCOMMON_OPT += $(foreach dcore,$(DYNAMIC_LIST),-DDYN_$(dcore))
endif
endif

ifeq ($(ARCH), loongarch64)
DYNAMIC_CORE = LOONGSON3R5 LOONGSON2K1000 LOONGSONGENERIC
endif

ifeq ($(ARCH), zarch)
DYNAMIC_CORE = ZARCH_GENERIC

# if the compiler accepts -march=arch11 or -march=z13 and can compile a file
# with z13-specific inline assembly, then we can include support for Z13.
# note: -march=z13 is equivalent to -march=arch11 yet some compiler releases
# only support one or the other.
# note: LLVM version 6.x supported -march=z13 yet could not handle vector
# registers in inline assembly, so the check for supporting the -march flag is
# not enough.
ZARCH_TEST_COMPILE=-c $(TOPDIR)/kernel/zarch/damin_z13.c -I$(TOPDIR) -o /dev/null > /dev/null 2> /dev/null
ZARCH_CC_SUPPORTS_ARCH11=$(shell $(CC) -march=arch11 $(ZARCH_TEST_COMPILE) && echo 1)
ZARCH_CC_SUPPORTS_Z13=$(shell $(CC) -march=z13 $(ZARCH_TEST_COMPILE) && echo 1)

ifeq ($(or $(ZARCH_CC_SUPPORTS_ARCH11), $(ZARCH_CC_SUPPORTS_Z13)), 1)
DYNAMIC_CORE += Z13
CCOMMON_OPT += -DDYN_Z13
else
$(info OpenBLAS: Not building Z13 kernels because the compiler $(CC) does not support it)
endif

# as above for z13, check for -march=arch12 and z14 support in the compiler.
ZARCH_CC_SUPPORTS_ARCH12=$(shell $(CC) -march=arch12 $(ZARCH_TEST_COMPILE) && echo 1)
ZARCH_CC_SUPPORTS_Z14=$(shell $(CC) -march=z14 $(ZARCH_TEST_COMPILE) && echo 1)
ifeq ($(or $(ZARCH_CC_SUPPORTS_ARCH12), $(ZARCH_CC_SUPPORTS_Z14)), 1)
DYNAMIC_CORE += Z14
CCOMMON_OPT += -DDYN_Z14
else
$(info OpenBLAS: Not building Z14 kernels because the compiler $(CC) does not support it)
endif

endif # ARCH zarch

ifeq ($(ARCH), power)
ifneq ($(C_COMPILER), PGI)
DYNAMIC_CORE = POWER6
DYNAMIC_CORE += POWER8
ifneq ($(C_COMPILER), GCC)
DYNAMIC_CORE += POWER9
DYNAMIC_CORE += POWER10
CCOMMON_OPT += -DHAVE_P10_SUPPORT
endif
ifeq ($(C_COMPILER), GCC)
ifeq ($(GCCVERSIONGT5), 1)
DYNAMIC_CORE += POWER9
else
$(info, OpenBLAS: Your gcc version is too old to build the POWER9 kernels.)
endif
ifeq ($(OSNAME), AIX)
LDVERSIONGTEQ35 := 1
else
LDVERSIONGTEQ35 := $(shell expr `$(CC) -Wl,--version 2> /dev/null | head -1 | cut -f2 -d "." | cut -f1 -d "-"` \>= 35)
endif
ifeq ($(GCCVERSIONGTEQ11)$(LDVERSIONGTEQ35), 11)
DYNAMIC_CORE += POWER10
CCOMMON_OPT += -DHAVE_P10_SUPPORT
else ifeq ($(GCCVERSIONGTEQ10), 1)
ifeq ($(GCCMINORVERSIONGTEQ2)$(LDVERSIONGTEQ35), 11)
DYNAMIC_CORE += POWER10
CCOMMON_OPT += -DHAVE_P10_SUPPORT
endif
else
$(info, OpenBLAS: Your gcc version is too old to build the POWER10 kernels.)
endif
endif
else
DYNAMIC_CORE = POWER8
DYNAMIC_CORE += POWER9
endif
endif

# If DYNAMIC_CORE is not set, DYNAMIC_ARCH cannot do anything, so force it to empty
ifndef DYNAMIC_CORE
override DYNAMIC_ARCH=
endif
endif

ifeq ($(ARCH), ia64)
NO_BINARY_MODE	= 1
BINARY_DEFINED	= 1

ifeq ($(F_COMPILER), GFORTRAN)
ifeq ($(C_COMPILER), GCC)
# EXPRECISION	= 1
# CCOMMON_OPT	+= -DEXPRECISION
endif
endif
endif

ifeq ($(ARCH), $(filter $(ARCH),mips64 mips))
NO_BINARY_MODE	= 1
endif

ifeq ($(ARCH), alpha)
NO_BINARY_MODE	= 1
BINARY_DEFINED	= 1
endif

ifeq ($(ARCH), arm)
NO_BINARY_MODE  = 1
BINARY_DEFINED  = 1

ifneq ($(EMBEDDED), 1)
CCOMMON_OPT += -marm
FCOMMON_OPT += -marm
else
CCOMMON_OPT += -DOS_EMBEDDED -mthumb -mcpu=cortex-m4 -mfloat-abi=hard -mfpu=fpv4-sp-d16
endif

# If softfp abi is mentioned on the command line, force it.
ifeq ($(ARM_SOFTFP_ABI), 1)
CCOMMON_OPT += -mfloat-abi=softfp
FCOMMON_OPT += -mfloat-abi=softfp
endif

ifeq ($(OSNAME), Android)
ifeq ($(ARM_SOFTFP_ABI), 1)
EXTRALIB	+= -lm
else
EXTRALIB	+= -Wl,-lm_hard
endif
endif
endif

ifeq ($(ARCH), arm64)
NO_BINARY_MODE  = 1
BINARY_DEFINED  = 1
ifdef INTERFACE64
ifneq ($(INTERFACE64), 0)
ifeq ($(F_COMPILER), GFORTRAN)
FCOMMON_OPT +=  -fdefault-integer-8
endif
ifeq ($(F_COMPILER), FLANG)
FCOMMON_OPT += -i8
endif
endif
endif
endif

ifeq ($(ARCH), riscv64)
NO_BINARY_MODE  = 1
BINARY_DEFINED  = 1
ifdef INTERFACE64
ifneq ($(INTERFACE64), 0)
ifeq ($(F_COMPILER), GFORTRAN)
FCOMMON_OPT +=  -fdefault-integer-8
endif
ifeq ($(F_COMPILER), FLANG)
FCOMMON_OPT += -i8
endif
endif
endif
endif

ifeq ($(ARCH), loongarch64)
NO_BINARY_MODE  = 1
BINARY_DEFINED  = 1
ifdef INTERFACE64
ifneq ($(INTERFACE64), 0)
ifeq ($(F_COMPILER), GFORTRAN)
FCOMMON_OPT +=  -fdefault-integer-8
endif
ifeq ($(F_COMPILER), FLANG)
FCOMMON_OPT += -i8
endif
endif
endif
endif

ifeq ($(ARCH), csky)
NO_BINARY_MODE	= 1
BINARY_DEFINED	= 1
endif

#
#  C Compiler dependent settings
#


# ifeq logical or. GCC or CLANG or LSB
# http://stackoverflow.com/questions/7656425/makefile-ifeq-logical-or
ifeq ($(C_COMPILER), $(filter $(C_COMPILER),GCC CLANG LSB))
CCOMMON_OPT += -Wall
COMMON_PROF += -fno-inline
NO_UNINITIALIZED_WARN =  -Wno-uninitialized

ifeq ($(QUIET_MAKE), 1)
CCOMMON_OPT += $(NO_UNINITIALIZED_WARN) -Wno-unused
endif

ifdef NO_BINARY_MODE

ifeq ($(ARCH), $(filter $(ARCH),mips64))
ifdef BINARY64
CCOMMON_OPT += -mabi=64
else
CCOMMON_OPT += -mabi=n32
endif
BINARY_DEFINED = 1
else ifeq ($(ARCH), $(filter $(ARCH),mips))
CCOMMON_OPT += -mabi=32
BINARY_DEFINED = 1
endif

ifneq (, $(filter $(CORE), MIPS64_GENERIC))
CCOMMON_OPT += -DNO_MSA
FCOMMON_OPT += -DNO_MSA
endif

ifneq (, $(filter $(CORE),LOONGSON3R3 LOONGSON3R4))
CCOMMON_OPT += -march=loongson3a
FCOMMON_OPT += -march=loongson3a
endif

ifeq ($(CORE), MIPS24K)
CCOMMON_OPT += -mips32r2 -mtune=24kc  $(MSA_FLAGS)
FCOMMON_OPT += -mips32r2 -mtune=24kc  $(MSA_FLAGS)
endif

ifeq ($(CORE), MIPS1004K)
CCOMMON_OPT += -mips32r2   $(MSA_FLAGS)
FCOMMON_OPT += -mips32r2   $(MSA_FLAGS)
endif

ifeq ($(CORE), P5600)
CCOMMON_OPT += -mips32r5 -mnan=2008 -mtune=p5600  $(MSA_FLAGS)
FCOMMON_OPT += -mips32r5 -mnan=2008 -mtune=p5600  $(MSA_FLAGS)
endif

ifeq ($(CORE), I6400)
CCOMMON_OPT += -mips64r6 -mnan=2008 -mtune=i6400 $(MSA_FLAGS)
FCOMMON_OPT += -mips64r6 -mnan=2008 -mtune=i6400 $(MSA_FLAGS)
endif

ifeq ($(CORE), P6600)
CCOMMON_OPT += -mips64r6 -mnan=2008 -mtune=p6600 $(MSA_FLAGS)
FCOMMON_OPT += -mips64r6 -mnan=2008 -mtune=p6600 $(MSA_FLAGS)
endif

ifeq ($(CORE), I6500)
CCOMMON_OPT += -mips64r6 -mnan=2008 -mtune=i6400 $(MSA_FLAGS)
FCOMMON_OPT += -mips64r6 -mnan=2008 -mtune=i6400 $(MSA_FLAGS)
endif

ifeq ($(OSNAME), AIX)
BINARY_DEFINED = 1
endif

ifeq ($(ARCH), loongarch64)
LA64_ABI=$(shell $(CC) -mabi=lp64d -c $(TOPDIR)/cpuid_loongarch64.c -o /dev/null > /dev/null 2> /dev/null && echo lp64d)
LA64_ARCH=$(shell $(CC) -march=loongarch64 -c $(TOPDIR)/cpuid_loongarch64.c -o /dev/null > /dev/null 2> /dev/null && echo loongarch64)
ifneq ($(LA64_ABI), lp64d)
LA64_ABI=lp64
endif
ifneq ($(LA64_ARCH), loongarch64)
CCOMMON_OPT += -mabi=$(LA64_ABI)
FCOMMON_OPT += -mabi=$(LA64_ABI)
else
CCOMMON_OPT += -march=loongarch64 -mabi=$(LA64_ABI)
FCOMMON_OPT += -march=loongarch64 -mabi=$(LA64_ABI)
endif
endif

endif

ifndef BINARY_DEFINED
ifneq ($(OSNAME), AIX)
ifdef BINARY64
ifneq ($(ARCH), riscv64)
CCOMMON_OPT += -m64
endif
else
CCOMMON_OPT += -m32
endif
endif
endif

endif

ifeq ($(C_COMPILER), PGI)
PGCVERSIONGT20 := $(shell expr `$(CC) --version|sed -n "2p" |sed -e "s/[^0-9.]//g" |cut -d "." -f 1` \> 20)
PGCVERSIONEQ20 := $(shell expr `$(CC) --version|sed -n "2p" |sed -e "s/[^0-9.]//g" |cut -d "." -f 1` == 20)
PGCMINORVERSIONGE11 := $(shell expr `$(CC) --version|sed -n "2p" |cut -d "-" -f 1 |sed -e "s/[^0-9.]//g" |cut -c 4-5` \>= 11)
PGCVERSIONCHECK := $(PGCVERSIONGT20)$(PGCVERSIONEQ20)$(PGCMINORVERSIONGE11)
ifeq ($(PGCVERSIONCHECK), $(filter $(PGCVERSIONCHECK), 100 101 011))
NEWPGI := 1
PGCVERSIONGT21 := $(shell expr `$(CC) --version|sed -n "2p" |sed -e "s/[^0-9.]//g" |cut -d "." -f 1` \> 21)
PGCVERSIONEQ21 := $(shell expr `$(CC) --version|sed -n "2p" |sed -e "s/[^0-9.]//g" |cut -d "." -f 1` == 21)
PGCVERSIONCHECK2 := $(PGCVERSIONGT21)$(PGCVERSIONEQ21)$(PGCMINORVERSIONGE11)
ifeq ($(PGCVERSIONCHECK2), $(filter $(PGCVERSIONCHECK2), 100 101 011))
NEWPGI2 := 1
endif
endif
ifdef BINARY64
ifeq ($(ARCH), x86_64)
ifeq (,$(findstring tp,$(CFLAGS)))
ifneq ($(NEWPGI2),1)
CCOMMON_OPT += -tp p7-64
else
CCOMMON_OPT += -tp px
endif
endif
ifneq ($(NEWPGI),1)
CCOMMON_OPT +=  -D__MMX__ -Mnollvm
endif
else
ifeq ($(ARCH), power)
ifeq (,$(findstring tp,$(CFLAGS)))
ifeq ($(CORE), POWER8)
CCOMMON_OPT += -tp pwr8
endif
ifeq ($(CORE), POWER9)
CCOMMON_OPT += -tp pwr9
endif
endif
endif
endif
else
ifneq ($(NEWPGI2),1)
ifeq (,$(findstring tp,$(CFLAGS)))
CCOMMON_OPT += -tp p7
else
CCOMMON_OPT += -tp px
endif
endif
endif
endif

ifeq ($(C_COMPILER), PATHSCALE)
ifdef BINARY64
CCOMMON_OPT += -m64
else
CCOMMON_OPT += -m32
endif
endif

#
#  Fortran Compiler dependent settings
#

ifeq ($(F_COMPILER), NAG)
FCOMMON_OPT += -dcfuns -recursive -ieee=full -w=obs -thread_safe
ifdef INTERFACE64
ifneq ($(INTERFACE64), 0)
FCOMMON_OPT += -i8
endif
endif
ifeq ($(USE_OPENMP), 1)
FCOMMON_OPT += -openmp
endif
endif

ifeq ($(F_COMPILER), FLANG)
CCOMMON_OPT += -DF_INTERFACE_FLANG
FCOMMON_OPT += -Mrecursive -Kieee
ifeq ($(OSNAME), Linux)
ifeq ($(ARCH), x86_64)
FLANG_VENDOR := $(shell $(FC) --version|head -1 |cut -f 1 -d " ")
ifeq ($(FLANG_VENDOR), AMD)
FCOMMON_OPT += -fno-unroll-loops
endif
endif
endif
ifdef BINARY64
ifdef INTERFACE64
ifneq ($(INTERFACE64), 0)
FCOMMON_OPT += -i8
endif
endif
FCOMMON_OPT += -Wall
else
FCOMMON_OPT += -Wall
endif
ifeq ($(USE_OPENMP), 1)
FCOMMON_OPT += -fopenmp
endif
endif

ifeq ($(F_COMPILER), G77)
CCOMMON_OPT += -DF_INTERFACE_G77
FCOMMON_OPT += -Wall
ifndef NO_BINARY_MODE
ifneq ($(OSNAME), AIX)
ifdef BINARY64
FCOMMON_OPT += -m64
else
FCOMMON_OPT += -m32
endif
endif
endif
endif

ifeq ($(F_COMPILER), G95)
CCOMMON_OPT += -DF_INTERFACE_G95
FCOMMON_OPT += -Wall
ifneq ($(OSNAME), AIX)
ifndef NO_BINARY_MODE
ifdef BINARY64
FCOMMON_OPT += -m64
else
FCOMMON_OPT += -m32
endif
endif
ifneq ($(NO_LAPACKE), 1)
FCOMMON_OPT += -fno-second-underscore
endif
endif
endif

ifeq ($(F_COMPILER), $(filter $(F_COMPILER),GFORTRAN FLANGNEW))
CCOMMON_OPT += -DF_INTERFACE_GFORT
ifeq ($(F_COMPILER), GFORTRAN)
FCOMMON_OPT += -Wall
# make single-threaded LAPACK calls thread-safe #1847
FCOMMON_OPT += -frecursive
# work around ABI problem with passing single-character arguments
FCOMMON_OPT += -fno-optimize-sibling-calls
#Don't include -lgfortran, when NO_LAPACK=1 or lsbcc
ifneq ($(NOFORTRAN), 1)
ifneq ($(NOFORTRAN), 2)
ifneq ($(NO_LAPACK), 1)
EXTRALIB += -lgfortran
endif
endif
endif
endif
ifdef NO_BINARY_MODE
ifeq ($(ARCH), $(filter $(ARCH),mips64))
ifdef BINARY64
FCOMMON_OPT += -mabi=64
else
FCOMMON_OPT += -mabi=n32
endif
else ifeq ($(ARCH), $(filter $(ARCH),mips))
FCOMMON_OPT += -mabi=32
endif
else
ifdef BINARY64
ifneq ($(OSNAME), AIX)
ifneq ($(ARCH), riscv64)
FCOMMON_OPT += -m64
endif
endif
ifdef INTERFACE64
ifneq ($(INTERFACE64), 0)
FCOMMON_OPT +=  -fdefault-integer-8
endif
endif
else
ifneq ($(OSNAME), AIX)
FCOMMON_OPT += -m32
endif
endif
endif
ifeq ($(USE_OPENMP), 1)
FCOMMON_OPT += -fopenmp
endif
endif

ifeq ($(F_COMPILER), INTEL)
CCOMMON_OPT += -DF_INTERFACE_INTEL
ifdef INTERFACE64
ifneq ($(INTERFACE64), 0)
FCOMMON_OPT += -i8
endif
endif
FCOMMON_OPT += -recursive -fp-model strict -assume protect-parens
ifeq ($(USE_OPENMP), 1)
FCOMMON_OPT += -fopenmp
endif
endif

ifeq ($(F_COMPILER), FUJITSU)
CCOMMON_OPT += -DF_INTERFACE_FUJITSU
ifeq ($(USE_OPENMP), 1)
FCOMMON_OPT += -openmp
endif
endif

ifeq ($(F_COMPILER), IBM)
CCOMMON_OPT += -DF_INTERFACE_IBM
FEXTRALIB += -lxlf90
ifeq ($(C_COMPILER), $(filter $(C_COMPILER),GCC CLANG))
FCOMMON_OPT += -qextname -qzerosize
endif
# FCOMMON_OPT	+= -qarch=440
ifdef BINARY64
FCOMMON_OPT += -q64
ifdef INTERFACE64
ifneq ($(INTERFACE64), 0)
FCOMMON_OPT += -qintsize=8
endif
endif
else
FCOMMON_OPT += -q32
endif
endif

ifeq ($(F_COMPILER), PGI)
CCOMMON_OPT  += -DF_INTERFACE_PGI
COMMON_PROF +=  -DPGICOMPILER
ifdef BINARY64
ifdef INTERFACE64
ifneq ($(INTERFACE64), 0)
FCOMMON_OPT += -i8
endif
endif
ifeq ($(ARCH), x86_64)
ifneq ($(NEWPGI2),1)
FCOMMON_OPT += -tp p7-64
else
FCOMMON_OPT += -tp px
endif
else
ifeq ($(ARCH), power)
ifeq ($(CORE), POWER6)
$(warning NVIDIA HPC compilers do not support POWER6.)
endif
ifeq ($(CORE), POWER8)
FCOMMON_OPT += -tp pwr8
endif
ifeq ($(CORE), POWER9)
FCOMMON_OPT += -tp pwr9
endif
ifeq ($(CORE), POWER10)
$(warning NVIDIA HPC compilers do not support POWER10.)
endif
endif
endif
else
FCOMMON_OPT += -tp p7
endif
FCOMMON_OPT += -Mrecursive -Kieee
ifeq ($(USE_OPENMP), 1)
FCOMMON_OPT += -mp
endif
endif

ifeq ($(F_COMPILER), PATHSCALE)
CCOMMON_OPT  += -DF_INTERFACE_PATHSCALE
ifdef BINARY64
ifdef INTERFACE64
ifneq ($(INTERFACE64), 0)
FCOMMON_OPT += -i8
endif
endif
endif
 
ifeq ($(USE_OPENMP), 1)
FCOMMON_OPT += -mp
endif
endif

ifeq ($(F_COMPILER), OPEN64)
CCOMMON_OPT  += -DF_INTERFACE_OPEN64
ifdef BINARY64
ifdef INTERFACE64
ifneq ($(INTERFACE64), 0)
FCOMMON_OPT += -i8
endif
endif
endif
ifeq ($(ARCH), $(filter $(ARCH),mips64 mips))
ifndef BINARY64
FCOMMON_OPT += -n32
else
FCOMMON_OPT += -n64
endif
ifeq ($(CORE), LOONGSON3R3)
FCOMMON_OPT += -loongson3 -static
endif
ifeq ($(CORE), LOONGSON3R4)
FCOMMON_OPT += -loongson3 -static
endif
else
ifndef BINARY64
FCOMMON_OPT += -m32
else
FCOMMON_OPT += -m64
endif
endif
ifeq ($(USE_OPENMP), 1)
FEXTRALIB   += -lstdc++
FCOMMON_OPT += -mp
endif
endif

ifeq ($(C_COMPILER), OPEN64)
ifeq ($(ARCH), $(filter $(ARCH),mips64 mips))
ifndef BINARY64
CCOMMON_OPT += -n32
else
CCOMMON_OPT += -n64
endif
ifeq ($(CORE), LOONGSON3R3)
CCOMMON_OPT += -loongson3 -static
endif
ifeq ($(CORE), LOONGSON3R4)
CCOMMON_OPT += -loongson3 -static
endif
else
ifndef BINARY64
CCOMMON_OPT += -m32
else
CCOMMON_OPT += -m64
endif
endif
endif

ifeq ($(C_COMPILER), SUN)
CCOMMON_OPT  += -w
ifeq ($(ARCH), x86)
CCOMMON_OPT  += -m32
else
ifdef BINARY64
CCOMMON_OPT  += -m64
else
CCOMMON_OPT  += -m32
endif
endif
endif

ifeq ($(F_COMPILER), SUN)
CCOMMON_OPT  += -DF_INTERFACE_SUN
FCOMMON_OPT  += -ftrap=%none -xrecursive
ifeq ($(ARCH), x86)
FCOMMON_OPT  += -m32
else
ifdef BINARY64
FCOMMON_OPT  += -m64
else
FCOMMON_OPT  += -m32
endif
endif
ifeq ($(USE_OPENMP), 1)
FCOMMON_OPT += -xopenmp=parallel
endif
endif

ifeq ($(F_COMPILER), COMPAQ)
CCOMMON_OPT  += -DF_INTERFACE_COMPAQ
ifeq ($(USE_OPENMP), 1)
FCOMMON_OPT += -openmp
endif
endif

ifeq ($(F_COMPILER), CRAY)
CCOMMON_OPT += -DF_INTERFACE_INTEL
FCOMMON_OPT += -hnopattern
ifdef INTERFACE64
ifneq ($(INTERFACE64), 0)
FCOMMON_OPT += -s integer64
endif
endif
ifneq ($(USE_OPENMP), 1)
FCOMMON_OPT += -O noomp
endif
endif

ifdef BINARY64
ifdef INTERFACE64
ifneq ($(INTERFACE64), 0)
CCOMMON_OPT	+=
#-DUSE64BITINT
endif
endif
endif

ifeq ($(NEED_PIC), 1)
ifeq ($(C_COMPILER), IBM)
CCOMMON_OPT += -qpic=large
else
CCOMMON_OPT += -fPIC
endif
ifeq ($(F_COMPILER), SUN)
FCOMMON_OPT  += -pic
else ifeq ($(F_COMPILER), NAG)
FCOMMON_OPT += -PIC
else ifeq ($(F_COMPILER), IBM)
FCOMMON_OPT += -qpic=large
else
FCOMMON_OPT += -fPIC
endif
endif

ifeq ($(DYNAMIC_ARCH), 1)
CCOMMON_OPT	+= -DDYNAMIC_ARCH
endif

ifeq ($(DYNAMIC_OLDER), 1)
CCOMMON_OPT	+= -DDYNAMIC_OLDER
endif

ifeq ($(C_LAPACK), 1)
CCOMMON_OPT	+= -DC_LAPACK
endif

ifeq ($(NO_LAPACK), 1)
CCOMMON_OPT	+= -DNO_LAPACK
#Disable LAPACK C interface
NO_LAPACKE = 1
endif

ifeq ($(NO_LAPACKE), 1)
CCOMMON_OPT	+= -DNO_LAPACKE
endif

ifeq ($(NO_AVX), 1)
CCOMMON_OPT	+= -DNO_AVX
endif

ifeq ($(ARCH), x86)
CCOMMON_OPT	+= -DNO_AVX
endif

ifeq ($(NO_AVX2), 1)
CCOMMON_OPT	+= -DNO_AVX2
endif

ifeq ($(NO_AVX512), 1)
CCOMMON_OPT	+= -DNO_AVX512
endif

ifeq ($(NO_SVE), 1)
CCOMMON_OPT     += -DNO_SVE
endif

ifdef SMP
CCOMMON_OPT	+= -DSMP_SERVER

ifeq ($(ARCH), mips64)
USE_SIMPLE_THREADED_LEVEL3 = 1
endif

ifeq ($(USE_OPENMP), 1)
# USE_SIMPLE_THREADED_LEVEL3 = 1
# NO_AFFINITY = 1
CCOMMON_OPT	+= -DUSE_OPENMP
endif

ifeq ($(BIGNUMA), 1)
CCOMMON_OPT	+= -DBIGNUMA
endif

endif

ifeq ($(NO_WARMUP), 1)
CCOMMON_OPT	+= -DNO_WARMUP
endif

ifeq ($(CONSISTENT_FPCSR), 1)
CCOMMON_OPT	+= -DCONSISTENT_FPCSR
endif

# Only for development
# CCOMMON_OPT	 += -DPARAMTEST
# CCOMMON_OPT	 += -DPREFETCHTEST
# CCOMMON_OPT	 += -DNO_SWITCHING
# USE_PAPI = 1

ifdef USE_PAPI
CCOMMON_OPT	 += -DUSE_PAPI
EXTRALIB	 += -lpapi -lperfctr
endif

ifdef BUFFERSIZE
CCOMMON_OPT	 += -DBUFFERSIZE=$(BUFFERSIZE)
endif

ifdef DYNAMIC_THREADS
CCOMMON_OPT	 += -DDYNAMIC_THREADS
endif

CCOMMON_OPT	+= -DMAX_CPU_NUMBER=$(NUM_THREADS)

CCOMMON_OPT	+= -DMAX_PARALLEL_NUMBER=$(NUM_PARALLEL)

ifdef USE_SIMPLE_THREADED_LEVEL3
CCOMMON_OPT	+= -DUSE_SIMPLE_THREADED_LEVEL3
endif

ifeq ($(USE_TLS), 1)
CCOMMON_OPT += -DUSE_TLS
endif

ifeq ($(BUILD_BFLOAT16), 1)
CCOMMON_OPT += -DBUILD_BFLOAT16
endif
ifeq ($(BUILD_SINGLE), 1)
CCOMMON_OPT += -DBUILD_SINGLE=1
endif
ifeq ($(BUILD_DOUBLE), 1)
CCOMMON_OPT += -DBUILD_DOUBLE=1
endif
ifeq ($(BUILD_COMPLEX), 1)
CCOMMON_OPT += -DBUILD_COMPLEX=1
endif
ifeq ($(BUILD_COMPLEX16), 1)
CCOMMON_OPT += -DBUILD_COMPLEX16=1
endif

CCOMMON_OPT += -DVERSION=\"$(VERSION)\"

ifndef SYMBOLPREFIX
SYMBOLPREFIX =
endif

ifndef SYMBOLSUFFIX
SYMBOLSUFFIX =
endif

ifndef LIBSONAMEBASE
LIBSONAMEBASE = openblas
endif

ifndef LIBNAMEPREFIX
LIBNAMEPREFIX =
endif

SYMPREFIX=$(SYMBOLPREFIX)
ifeq ($(SYMBOLPREFIX),$(LIBNAMEPREFIX))
SYMPREFIX=
endif
SYMSUFFIX=$(SYMBOLSUFFIX)
ifeq ($(SYMBOLSUFFIX),$(LIBNAMESUFFIX))
SYMSUFFIX=
endif
ifndef LIBNAMESUFFIX
LIBNAMEBASE = $(SYMPREFIX)$(LIBSONAMEBASE)$(SYMSUFFIX)
else
LIBNAMEBASE = $(SYMPREFIX)$(LIBSONAMEBASE)$(SYMSUFFIX)$(LIBNAMESUFFIX)
endif

ifeq ($(OSNAME), CYGWIN_NT)
LIBPREFIX = cyg$(LIBNAMEPREFIX)$(LIBNAMEBASE)
else
LIBPREFIX = lib$(LIBNAMEPREFIX)$(LIBNAMEBASE)
endif

KERNELDIR	= $(TOPDIR)/kernel/$(ARCH)

include $(TOPDIR)/Makefile.$(ARCH)

ifneq ($(C_COMPILER), PGI)
ifneq ($(C_COMPILER), SUN)
CCOMMON_OPT     += -UASMNAME -UASMFNAME -UNAME -UCNAME -UCHAR_NAME -UCHAR_CNAME
endif
endif
CCOMMON_OPT	+= -DASMNAME=$(FU)$(*F) -DASMFNAME=$(FU)$(*F)$(BU) -DNAME=$(*F)$(BU) -DCNAME=$(*F) -DCHAR_NAME=\"$(*F)$(BU)\" -DCHAR_CNAME=\"$(*F)\"

ifeq ($(CORE), PPC440)
CCOMMON_OPT	+= -DALLOC_QALLOC
endif

ifeq ($(CORE), PPC440FP2)
STATIC_ALLOCATION = 1
endif

ifneq ($(OSNAME), Linux)
NO_AFFINITY = 1
endif

ifneq ($(ARCH), x86_64)
ifneq ($(ARCH), x86)
NO_AFFINITY = 1
endif
endif

ifdef NO_AFFINITY
ifeq ($(NO_AFFINITY), 0)
override undefine NO_AFFINITY
else
CCOMMON_OPT	+= -DNO_AFFINITY
endif
endif

ifdef FUNCTION_PROFILE
CCOMMON_OPT	+= -DFUNCTION_PROFILE
endif

ifdef SHMEM_ALLOCATION
ifneq ($(SHMEM_ALLOCATION), 0)
CCOMMON_OPT	+= -DALLOC_SHM
endif
endif

ifdef HUGETLB_ALLOCATION
ifneq ($(HUGETLB_ALLOCATION), 0)
CCOMMON_OPT	+= -DALLOC_HUGETLB
endif
endif

ifdef HUGETLBFILE_ALLOCATION
ifneq ($(HUGETLBFILE_ALLOCATION), 0)
CCOMMON_OPT	+= -DALLOC_HUGETLBFILE -DHUGETLB_FILE_NAME=$(HUGETLBFILE_ALLOCATION)
endif
endif

ifdef STATIC_ALLOCATION
CCOMMON_OPT	+= -DALLOC_STATIC
endif

ifdef DEVICEDRIVER_ALLOCATION
CCOMMON_OPT	+= -DALLOC_DEVICEDRIVER -DDEVICEDRIVER_NAME=\"/dev/mapper\"
endif

ifdef MIXED_MEMORY_ALLOCATION
CCOMMON_OPT	+= -DMIXED_MEMORY_ALLOCATION
endif

ifeq ($(OSNAME), SunOS)
TAR	= gtar
PATCH	= gpatch
GREP	= ggrep
AWK	= nawk
else
TAR	= tar
PATCH	= patch
GREP	= grep
AWK	= awk
endif

ifndef MD5SUM
MD5SUM	= md5sum
endif


REVISION = -r$(VERSION)
MAJOR_VERSION = $(word 1,$(subst ., ,$(VERSION)))

ifeq ($(DEBUG), 1)
COMMON_OPT += -g
endif

ifeq ($(DEBUG), 1)
FCOMMON_OPT += -g
endif

ifndef COMMON_OPT
COMMON_OPT = -O2
endif

ifndef FCOMMON_OPT
FCOMMON_OPT = -O2 -frecursive
endif

override CFLAGS     += $(COMMON_OPT) $(CCOMMON_OPT) -I$(TOPDIR)
override PFLAGS     += $(COMMON_OPT) $(CCOMMON_OPT) -I$(TOPDIR) -DPROFILE $(COMMON_PROF)
override FFLAGS     += $(COMMON_OPT) $(FCOMMON_OPT)
override FPFLAGS    += $(FCOMMON_OPT) $(COMMON_PROF)
#MAKEOVERRIDES =

ifeq ($(NEED_PIC), 1)
ifeq (,$(findstring PIC,$(FFLAGS)))
ifneq ($(F_COMPILER),IBM)
override FFLAGS += -fPIC
endif
endif
endif

#For LAPACK Fortran codes.
#Disable -fopenmp for LAPACK Fortran codes on Windows.
ifdef OS_WINDOWS
LAPACK_FFLAGS := $(filter-out -fopenmp -mp -openmp -xopenmp=parallel,$(FFLAGS))
LAPACK_FPFLAGS := $(filter-out -fopenmp -mp -openmp -xopenmp=parallel,$(FPFLAGS))
else
LAPACK_FFLAGS := $(FFLAGS)
LAPACK_FPFLAGS := $(FPFLAGS)
endif

ifeq ($(F_COMPILER),NAG)
LAPACK_FFLAGS := $(filter-out -msse3 -mssse3 -msse4.1 -mavx -mavx2 -mskylake-avx512 ,$(FFLAGS))
override FFLAGS := $(filter-out -msse3 -mssse3 -msse4.1 -mavx -mavx2 -mskylake-avx512 ,$(FFLAGS))
endif
ifeq ($(F_COMPILER),CRAY)
LAPACK_FFLAGS := $(filter-out -msse3 -mssse3 -msse4.1 -mavx -mavx2 -mskylake-avx512 ,$(FFLAGS))
override FFLAGS := $(filter-out -msse3 -mssse3 -msse4.1 -mavx -mavx2 -mskylake-avx512 ,$(FFLAGS))
endif
ifeq ($(F_COMPILER),FLANGNEW)
LAPACK_FFLAGS := $(filter-out -m32 -m64 -msse3 -mssse3 -msse4.1 -mavx -mavx2 -mskylake-avx512 ,$(FFLAGS))
override FFLAGS := $(filter-out -m32 -m64 -msse3 -mssse3 -msse4.1 -mavx -mavx2 -mskylake-avx512 ,$(FFLAGS))
endif

LAPACK_CFLAGS = $(CFLAGS)
LAPACK_CFLAGS += -DHAVE_LAPACK_CONFIG_H
ifdef INTERFACE64
ifneq ($(INTERFACE64), 0)
LAPACK_CFLAGS +=  -DLAPACK_ILP64
endif
endif

ifdef OS_WINDOWS
LAPACK_CFLAGS +=  -DOPENBLAS_OS_WINDOWS
LAPACK_CFLAGS +=  -DLAPACK_COMPLEX_STRUCTURE
endif
ifeq ($(C_COMPILER), LSB)
LAPACK_CFLAGS +=  -DLAPACK_COMPLEX_STRUCTURE
endif

ifndef SUFFIX
SUFFIX  = o
endif

ifndef PSUFFIX
PSUFFIX = po
endif

ifndef LIBSUFFIX
LIBSUFFIX = a
endif

ifneq ($(DYNAMIC_ARCH), 1)
ifndef SMP
LIBNAME		= $(LIBPREFIX)_$(LIBCORE)$(REVISION).$(LIBSUFFIX)
LIBNAME_P	= $(LIBPREFIX)_$(LIBCORE)$(REVISION)_p.$(LIBSUFFIX)
else
LIBNAME		= $(LIBPREFIX)_$(LIBCORE)p$(REVISION).$(LIBSUFFIX)
LIBNAME_P	= $(LIBPREFIX)_$(LIBCORE)p$(REVISION)_p.$(LIBSUFFIX)
endif
else
ifndef SMP
LIBNAME		= $(LIBPREFIX)$(REVISION).$(LIBSUFFIX)
LIBNAME_P	= $(LIBPREFIX)$(REVISION)_p.$(LIBSUFFIX)
else
LIBNAME		= $(LIBPREFIX)p$(REVISION).$(LIBSUFFIX)
LIBNAME_P	= $(LIBPREFIX)p$(REVISION)_p.$(LIBSUFFIX)
endif
endif

ifeq ($(FIXED_LIBNAME),1)
	LIBNAME = lib$(LIBNAMEPREFIX)$(LIBSONAMEBASE)$(LIBNAMESUFFIX).$(LIBSUFFIX)
	LIBNAME_P = lib$(LIBNAMEPREFIX)$(LISOBNAMEBASE)$(LIBNAMESUFFIX)_p.$(LIBSUFFIX)
endif

LIBDLLNAME   = $(LIBPREFIX).dll
IMPLIBNAME   = lib$(LIBNAMEBASE).dll.a
LIBSONAME    = $(LIBNAME:.$(LIBSUFFIX)=.so)
LIBDYNNAME   = $(LIBNAME:.$(LIBSUFFIX)=.dylib)
LIBDEFNAME   = $(LIBNAME:.$(LIBSUFFIX)=.def)
LIBEXPNAME   = $(LIBNAME:.$(LIBSUFFIX)=.exp)
LIBZIPNAME   = $(LIBNAME:.$(LIBSUFFIX)=.zip)

LIBS		= $(TOPDIR)/$(LIBNAME)
LIBS_P		= $(TOPDIR)/$(LIBNAME_P)


LIB_COMPONENTS = BLAS
ifneq ($(NO_CBLAS), 1)
LIB_COMPONENTS += CBLAS
endif

ifneq ($(NO_LAPACK), 1)
LIB_COMPONENTS += LAPACK
ifneq ($(NO_LAPACKE), 1)
LIB_COMPONENTS += LAPACKE
endif
ifeq ($(BUILD_RELAPACK), 1)
LIB_COMPONENTS += ReLAPACK
endif
endif

ifeq ($(ONLY_CBLAS), 1)
LIB_COMPONENTS = CBLAS
endif

export OSNAME
export ARCH
export CORE
export LIBCORE
export __BYTE_ORDER__
export ELF_VERSION
export PGCPATH
export CONFIG
export CC
export FC
export BU
export FU
export NEED2UNDERSCORES
export USE_THREAD
export NUM_THREADS
export NUM_CORES
export SMP
export MAKEFILE_RULE
export NEED_PIC
export BINARY
export BINARY32
export BINARY64
export F_COMPILER
export C_COMPILER
export USE_OPENMP
export CROSS
export CROSS_SUFFIX
export NOFORTRAN
export C_LAPACK
export NO_FBLAS
export EXTRALIB
export CEXTRALIB
export FEXTRALIB
export HAVE_SSE
export HAVE_SSE2
export HAVE_SSE3
export HAVE_SSSE3
export HAVE_SSE4_1
export HAVE_SSE4_2
export HAVE_SSE4A
export HAVE_SSE5
export HAVE_AVX
export HAVE_AVX2
export HAVE_FMA3
export HAVE_VFP
export HAVE_VFPV3
export HAVE_VFPV4
export HAVE_NEON
ifndef NO_MSA
  export HAVE_MSA
  export MSA_FLAGS
endif
export KERNELDIR
export FUNCTION_PROFILE
export TARGET_CORE
export NO_AVX512
export NO_AVX2
export BUILD_BFLOAT16
export NO_LSX
export NO_LASX

export SBGEMM_UNROLL_M
export SBGEMM_UNROLL_N
export SGEMM_UNROLL_M
export SGEMM_UNROLL_N
export DGEMM_UNROLL_M
export DGEMM_UNROLL_N
export QGEMM_UNROLL_M
export QGEMM_UNROLL_N
export CGEMM_UNROLL_M
export CGEMM_UNROLL_N
export ZGEMM_UNROLL_M
export ZGEMM_UNROLL_N
export XGEMM_UNROLL_M
export XGEMM_UNROLL_N
export CGEMM3M_UNROLL_M
export CGEMM3M_UNROLL_N
export ZGEMM3M_UNROLL_M
export ZGEMM3M_UNROLL_N
export XGEMM3M_UNROLL_M
export XGEMM3M_UNROLL_N


ifdef USE_CUDA
export CUDADIR
export CUCC
export CUFLAGS
export CULIB
endif

.SUFFIXES: .$(PSUFFIX) .$(SUFFIX) .f

.f.$(SUFFIX):
	$(FC) $(FFLAGS) -c $<  -o $(@F)

.f.$(PSUFFIX):
	$(FC) $(FPFLAGS) -pg -c $<  -o $(@F)


ifdef BINARY64
PATHSCALEPATH	= /opt/pathscale/lib/3.1
PGIPATH		= /opt/pgi/linux86-64/7.1-5/lib
else
PATHSCALEPATH	= /opt/pathscale/lib/3.1/32
PGIPATH		= /opt/pgi/linux86/7.1-5/lib
endif

ACMLPATH	= /opt/acml/4.3.0
ifneq ($(OSNAME), Darwin)
MKLPATH         = /opt/intel/mkl/10.2.2.025/lib
else
MKLPATH         = /Library/Frameworks/Intel_MKL.framework/Versions/10.0.1.014/lib
endif
ATLASPATH	= /opt/atlas/3.9.17/opteron
FLAMEPATH	= $(HOME)/flame/lib
ifneq ($(OSNAME), SunOS)
SUNPATH		= /opt/sunstudio12.1
else
SUNPATH		= /opt/SUNWspro
endif

```
File: azure-pipelines.yml
```
trigger:
  # start a new build for every push
  batch: False
  branches:
    include:
      - develop
resources:
  containers:
      - container: oneapi-hpckit
        image: intel/oneapi-hpckit:latest
        options: '-v /usr/bin/sudo:/usr/bin/sudo -v /usr/lib/sudo/libsudo_util.so.0:/usr/lib/sudo/libsudo_util.so.0 -v /usr/lib/sudo/sudoers.so:/usr/lib/sudo/sudoers.so'
      - container: oneapi-basekit
        image: intel/oneapi-basekit:latest
        options: '-v /usr/bin/sudo:/usr/bin/sudo -v /usr/lib/sudo/libsudo_util.so.0:/usr/lib/sudo/libsudo_util.so.0 -v /usr/lib/sudo/sudoers.so:/usr/lib/sudo/sudoers.so'
 
jobs:
# manylinux1 is useful to test because the
# standard Docker container uses an old version
# of gcc / glibc
- job: manylinux1_gcc
  pool:
    vmImage: 'ubuntu-latest'
  steps:
  - script: |
      echo "FROM quay.io/pypa/manylinux1_x86_64
        COPY . /tmp/openblas
        RUN cd /tmp/openblas                                      &&  \
            COMMON_FLAGS='DYNAMIC_ARCH=1 TARGET=NEHALEM NUM_THREADS=32' && \
            BTYPE='BINARY=64' CC=gcc && \
            make QUIET_MAKE=1 $COMMON_FLAGS $BTYPE && \
            make -C test $COMMON_FLAGS $BTYPE && \
            make -C ctest $COMMON_FLAGS $BTYPE && \
            make -C utest $COMMON_FLAGS $BTYPE" > Dockerfile
      docker build .
    displayName: Run manylinux1 docker build
- job: Intel_SDE_skx
  pool:
    vmImage: 'ubuntu-latest'
  steps:
  - script: |
      # at the time of writing the available Azure Ubuntu vm image
      # does not support AVX512VL, so use more recent LTS version
      echo "FROM ubuntu:bionic
      COPY . /tmp/openblas
      RUN apt-get -y update && apt-get -y install \\
          cmake \\
          gfortran \\
          make \\
          wget
      RUN mkdir /tmp/SDE && cd /tmp/SDE && \\
          mkdir sde-external-8.35.0-2019-03-11-lin && \\
          wget --quiet -O sde-external-8.35.0-2019-03-11-lin.tar.bz2 https://www.dropbox.com/s/fopsnzj67572sj5/sde-external-8.35.0-2019-03-11-lin.tar.bz2?dl=0 && \\
          tar -xjvf sde-external-8.35.0-2019-03-11-lin.tar.bz2 -C /tmp/SDE/sde-external-8.35.0-2019-03-11-lin --strip-components=1
      RUN cd /tmp/openblas && CC=gcc make QUIET_MAKE=1 DYNAMIC_ARCH=1 NUM_THREADS=32 BINARY=64
      CMD cd /tmp/openblas && echo 0 > /proc/sys/kernel/yama/ptrace_scope && CC=gcc OPENBLAS_VERBOSE=2 /tmp/SDE/sde-external-8.35.0-2019-03-11-lin/sde64 -cpuid_in /tmp/SDE/sde-external-8.35.0-2019-03-11-lin/misc/cpuid/skx/cpuid.def -- make -C utest DYNAMIC_ARCH=1 NUM_THREADS=32 BINARY=64" > Dockerfile
      docker build -t intel_sde .
      # we need a privileged docker run for sde process attachment
      docker run --privileged intel_sde
    displayName: 'Run AVX512 SkylakeX docker build / test'

- job: Windows_cl
  pool:
     vmImage: 'windows-latest'
  steps:   
  - task: CMake@1
    inputs:
      workingDirectory: 'build' # Optional
      cmakeArgs: '-G "Visual Studio 17 2022" ..'
  - task: CMake@1
    inputs:
      cmakeArgs: '--build . --config Release'
      workingDirectory: 'build'
  - script: |
      cd build
      cd utest
      dir
      openblas_utest.exe

- job: Windows_mingw_gmake
  pool:
     vmImage: 'windows-latest'
  steps:   
  - script: |
      mingw32-make CC=gcc FC=gfortran DYNAMIC_ARCH=1 DYNAMIC_LIST="SANDYBRIDGE"

- job: Windows_clang_cmake
  pool:
     vmImage: 'windows-latest'
  steps:
  - script: |
      set "PATH=C:\Miniconda\Scripts;C:\Miniconda\Library\bin;C:\Miniconda\Library\usr\bin;C:\Miniconda\condabin;%PATH%"
      set "LIB=C:\Miniconda\Library\lib;%LIB%"
      set "CPATH=C:\Miniconda\Library\include;%CPATH%
      conda config --add channels conda-forge --force
      conda config --set auto_update_conda false
      conda install --yes ninja
      call "C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Auxiliary\Build\vcvars64.bat"
      mkdir build 
      cd build
      cmake -G "Ninja" -DCMAKE_C_COMPILER=clang-cl -DCMAKE_CXX_COMPILER=clang-cl -DCMAKE_MT=mt -DCMAKE_BUILD_TYPE=Release -DNOFORTRAN=1 -DMSVC_STATIC_CRT=ON ..
      cmake --build . --config Release
      ctest

- job: Windows_flang_clang
  pool:
     vmImage: 'windows-2022'
  steps:
  - script: |
      set "PATH=C:\Miniconda\Scripts;C:\Miniconda\Library\bin;C:\Miniconda\Library\usr\bin;C:\Miniconda\condabin;%PATH%"
      set "LIB=C:\Miniconda\Library\lib;%LIB%"
      set "CPATH=C:\Miniconda\Library\include;%CPATH%"
      conda config --add channels conda-forge --force
      conda config --set auto_update_conda false
      conda install --yes --quiet ninja flang
      mkdir build 
      cd build
      call "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Auxiliary\Build\vcvars64.bat"
      cmake -G "Ninja" -DCMAKE_C_COMPILER=clang-cl -DCMAKE_CXX_COMPILER=clang-cl -DCMAKE_Fortran_COMPILER="flang -I C:\Miniconda\Library\include\flang" -DBUILD_TESTING=OFF -DCMAKE_MT=mt -DCMAKE_BUILD_TYPE=Release -DMSVC_STATIC_CRT=ON ..
      cmake --build . --config Release
      ctest

- job: Windows_cl_flang
  pool:
     vmImage: 'windows-2022'
  steps:
  - script: |
      set "PATH=C:\Miniconda\Scripts;C:\Miniconda\Library\bin;C:\Miniconda\Library\usr\bin;C:\Miniconda\condabin;%PATH%"
      set "LIB=C:\Miniconda\Library\lib;%LIB%"
      set "CPATH=C:\Miniconda\Library\include;%CPATH%"
      conda config --add channels conda-forge --force
      conda config --set auto_update_conda false
      conda install --yes --quiet ninja flang
      mkdir build 
      cd build
      call "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Auxiliary\Build\vcvars64.bat"
      cmake -G "Ninja" -DCMAKE_C_COMPILER=cl -DCMAKE_Fortran_COMPILER=flang-new -DC_LAPACK=1 -DCMAKE_MT=mt -DCMAKE_BUILD_TYPE=Release -DMSVC_STATIC_CRT=ON ..
      cmake --build . --config Release
      ctest



- job: OSX_OpenMP
  pool:
     vmImage: 'macOS-11'
  steps:   
  - script: |
      brew update
      make TARGET=CORE2 DYNAMIC_ARCH=1 USE_OPENMP=1 INTERFACE64=1 CC=gcc-10 FC=gfortran-10
      make TARGET=CORE2 DYNAMIC_ARCH=1 USE_OPENMP=1 INTERFACE64=1 CC=gcc-10 FC=gfortran-10 PREFIX=../blasinst install
      ls -lR ../blasinst
     
- job: OSX_GCC_Nothreads
  pool:
     vmImage: 'macOS-11'
  steps:   
  - script: |
      brew update
      make USE_THREADS=0 CC=gcc-10 FC=gfortran-10
     
- job: OSX_GCC12
  pool:
     vmImage: 'macOS-latest'
  steps:   
  - script: |
      brew update
      make CC=gcc-12 FC=gfortran-12
     
- job: OSX_OpenMP_Clang
  pool:
     vmImage: 'macOS-latest'
  variables:
     LD_LIBRARY_PATH: /usr/local/opt/llvm/lib
     LIBRARY_PATH: /usr/local/opt/llvm/lib
  steps:   
  - script: |
      brew update
      brew install llvm libomp
      make TARGET=CORE2 USE_OPENMP=1 DYNAMIC_ARCH=1 CC=/usr/local/opt/llvm/bin/clang NOFORTRAN=1

- job: OSX_OpenMP_Clang_cmake
  pool:
     vmImage: 'macOS-latest'
  variables:
     LD_LIBRARY_PATH: /usr/local/opt/llvm/lib
     LIBRARY_PATH: /usr/local/opt/llvm/lib
  steps:   
  - script: |
      brew update
      brew install llvm libomp
      mkdir build
      cd build
      cmake -DTARGET=CORE2 -DUSE_OPENMP=1 -DINTERFACE64=1 -DDYNAMIC_ARCH=1 -DCMAKE_C_COMPILER=/usr/local/opt/llvm/bin/clang -DNOFORTRAN=1 -DNO_AVX512=1 ..
      make
      ctest
      
- job: OSX_dynarch_cmake
  pool:
     vmImage: 'macOS-11'
  variables:
     LD_LIBRARY_PATH: /usr/local/opt/llvm/lib
     LIBRARY_PATH: /usr/local/opt/llvm/lib
  steps:   
  - script: |
      mkdir build
      cd build
      cmake -DTARGET=CORE2 -DDYNAMIC_ARCH=1 -DDYNAMIC_LIST='NEHALEM HASWELL SKYLAKEX' -DCMAKE_C_COMPILER=gcc-10 -DCMAKE_Fortran_COMPILER=gfortran-10 -DBUILD_SHARED_LIBS=ON ..
      cmake --build .
      ctest

- job: OSX_Ifort_Clang
  pool:
     vmImage: 'macOS-latest'
  variables:
     LD_LIBRARY_PATH: /usr/local/opt/llvm/lib
     MACOS_HPCKIT_URL: https://registrationcenter-download.intel.com/akdlm/irc_nas/17643/m_HPCKit_p_2021.2.0.2903_offline.dmg
     LIBRARY_PATH: /usr/local/opt/llvm/lib
     MACOS_FORTRAN_COMPONENTS: intel.oneapi.mac.ifort-compiler
  steps:   
  - script: |
      brew update
      brew install llvm libomp
      sudo mkdir -p /opt/intel
      sudo chown $USER /opt/intel
    displayName: prepare for cache restore
  - task: Cache@2
    inputs:
      path: /opt/intel/oneapi
      key: '"install" | "$(MACOS_HPCKIT_URL)" | "$(MACOS_FORTRAN_COMPONENTS)"'
      cacheHitVar: CACHE_RESTORED
  - script: | 
      curl --output webimage.dmg --url $(MACOS_HPCKIT_URL) --retry 5 --retry-delay 5
      hdiutil attach webimage.dmg
      sudo /Volumes/"$(basename "$(MACOS_HPCKIT_URL)" .dmg)"/bootstrapper.app/Contents/MacOS/bootstrapper -s --action install --components="$(MACOS_FORTRAN_COMPONENTS)" --eula=accept --continue-with-optional-error=yes --log-dir=.
      installer_exit_code=$?
      hdiutil detach /Volumes/"$(basename "$URL" .dmg)" -quiet
      exit $installer_exit_code
    displayName: install
    condition: ne(variables.CACHE_RESTORED, 'true')
  - script: | 
      source /opt/intel/oneapi/setvars.sh
      make CC=/usr/local/opt/llvm/bin/clang FC=ifort
 
- job: OSX_NDK_ARMV7
  pool:
     vmImage: 'macOS-11'
  steps:   
  - script: | 
      brew update
      brew install --cask android-ndk
      export ANDROID_NDK_HOME=/usr/local/share/android-ndk
      make TARGET=ARMV7 ONLY_CBLAS=1 CC=$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/darwin-x86_64/bin/armv7a-linux-androideabi21-clang AR=$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/darwin-x86_64/bin/llvm-ar HOSTCC=gcc ARM_SOFTFP_ABI=1 -j4

- job: OSX_IOS_ARMV8
  pool:
     vmImage: 'macOS-11'
  variables:
     CC: /Applications/Xcode_12.4.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang
     CFLAGS: -O2 -Wno-macro-redefined -isysroot /Applications/Xcode_12.4.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS14.4.sdk -arch arm64 -miphoneos-version-min=10.0
  steps:
  - script: |
     make TARGET=ARMV8 DYNAMIC_ARCH=1 NUM_THREADS=32 HOSTCC=clang NOFORTRAN=1

- job: OSX_IOS_ARMV7
  pool:
     vmImage: 'macOS-11'
  variables:
     CC: /Applications/Xcode_12.4.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang
     CFLAGS: -O2 -mno-thumb -Wno-macro-redefined -isysroot /Applications/Xcode_12.4.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS14.4.sdk -arch armv7 -miphoneos-version-min=5.1
  steps:
  - script: |
     make TARGET=ARMV7 DYNAMIC_ARCH=1 NUM_THREADS=32 HOSTCC=clang NOFORTRAN=1

- job: OSX_xbuild_DYNAMIC_ARM64
  pool:
     vmImage: 'macOS-11'
  variables:
     CC: /Applications/Xcode_12.5.1.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang
     CFLAGS: -O2 -Wno-macro-redefined -isysroot /Applications/Xcode_12.5.1.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX11.3.sdk -arch arm64
  steps:
  - script: |
     ls /Applications/Xcode_12.5.1.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs
     /Applications/Xcode_12.5.1.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -arch arm64 --print-supported-cpus
     /Applications/Xcode_11.7.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang --version
     make TARGET=ARMV8 DYNAMIC_ARCH=1 NUM_THREADS=32 HOSTCC=clang NOFORTRAN=1

- job: ALPINE_MUSL
  pool:
     vmImage: 'ubuntu-latest'
  steps:
  - script: |
        wget https://raw.githubusercontent.com/alpinelinux/alpine-chroot-install/v0.14.0/alpine-chroot-install \
        && echo 'ccbf65f85cdc351851f8ad025bb3e65bae4d5b06  alpine-chroot-install' | sha1sum -c \
        || exit 1
        alpine() { /alpine/enter-chroot -u "$USER" "$@"; }
        sudo sh alpine-chroot-install -p 'build-base gfortran perl linux-headers sudo'
        alpine make DYNAMIC_ARCH=1 BINARY=64
        alpine make DYNAMIC_ARCH=1 BINARY=64 PREFIX=mytestdir install
        alpine ls -l mytestdir/include
        alpine echo "// tests that inclusion of openblas_config.h works with musl" >test_install.c
        alpine echo "#include <openblas_config.h>" >>test_install.c
        alpine echo "int main(){" >> test_install.c
        alpine echo "cpu_set_t* cpu_set = NULL;}" >>test_install.c
        alpine gcc -Imytestdir/include test_install.c -Lmytestdir/lib -lopenblas -lpthread -lgfortran -o test_install
        

```
File: Makefile.rule
```
#
#  Beginning of user configuration
#

# This library's version
VERSION = 0.3.27.dev

# If you set this prefix, the library name will be lib$(LIBNAMESUFFIX)openblas.a
# and lib$(LIBNAMESUFFIX)openblas.so, with a matching soname in the shared library
# 
# LIBNAMEPREFIX = scipy

# If you set the suffix, the library name will be libopenblas_$(LIBNAMESUFFIX).a
# and libopenblas_$(LIBNAMESUFFIX).so. Meanwhile, the soname in shared library
# is libopenblas_$(LIBNAMESUFFIX).so.0.
# LIBNAMESUFFIX = omp

# You can specify the target architecture, otherwise it's
# automatically detected.
# TARGET = PENRYN

# If you want to support multiple architecture in one binary
# DYNAMIC_ARCH = 1

# If you want the full list of x86_64 architectures supported in DYNAMIC_ARCH
# mode (including individual optimizied codes for PENRYN, DUNNINGTON, OPTERON,
# OPTERON_SSE3, ATOM and NANO rather than fallbacks to older architectures)
# DYNAMIC_OLDER = 1

# C compiler including binary type(32bit / 64bit). Default is gcc.
# Don't use Intel Compiler or PGI, it won't generate right codes as I expect.
# CC = gcc

# Fortran compiler. Default is g77.
# FC = gfortran

# Even you can specify cross compiler. Meanwhile, please set HOSTCC.

# cross compiler for Windows
# CC = x86_64-w64-mingw32-gcc
# FC = x86_64-w64-mingw32-gfortran

# cross compiler for 32bit ARM
# CC = arm-linux-gnueabihf-gcc
# FC = arm-linux-gnueabihf-gfortran

# cross compiler for 64bit ARM
# CC = aarch64-linux-gnu-gcc
# FC = aarch64-linux-gnu-gfortran


# If you use the cross compiler, please set this host compiler.
# HOSTCC = gcc

# If you need 32bit binary, define BINARY=32, otherwise define BINARY=64
# Please note that AVX is not available on 32-bit.
# Setting BINARY=32 disables AVX/AVX2/AVX-512.
# BINARY=64

# About threaded BLAS. It will be automatically detected if you don't
# specify it.
# For force setting for single threaded, specify USE_THREAD = 0
# For force setting for multi  threaded, specify USE_THREAD = 1
# USE_THREAD = 0

# If you want to build a single-threaded OpenBLAS, but expect to call this
# from several concurrent threads in some other program, comment this in for
# thread safety. (This is done automatically for USE_THREAD=1 , and should not
# be necessary when USE_OPENMP=1)
# USE_LOCKING = 1

# If you're going to use this library with OpenMP, please comment it in.
# This flag is always set for POWER8. Don't set USE_OPENMP = 0 if you're targeting POWER8.
# USE_OPENMP = 1

# The OpenMP scheduler to use - by default this is "static" and you
# will normally not want to change this unless you know that your main
# workload will involve tasks that have highly unbalanced running times
# for individual threads. Changing away from "static" may also adversely
# affect memory access locality in NUMA systems. Setting to "runtime" will
# allow you to select the scheduler from the environment variable OMP_SCHEDULE
# CCOMMON_OPT += -DOMP_SCHED=dynamic

# You can define the maximum number of threads. Basically it should be less
# than or equal to the number of CPU threads. If you don't specify one, it's
# automatically detected by the build system.
# If SMT (aka. HT) is enabled on the system, it may or may not be beneficial to 
# restrict NUM_THREADS to the number of physical cores. By default, the automatic 
# detection includes logical CPUs, thus allowing the use of SMT.
# Users may opt at runtime to use less than NUM_THREADS threads.
#
# Note for package maintainers: you can build OpenBLAS with a large NUM_THREADS
# value (eg. 32-256) if you expect your users to use that many threads. Due to the way
# some internal structures are allocated, using a large NUM_THREADS value has a RAM
# footprint penalty, even if users reduce the actual number of threads at runtime.
# NUM_THREADS = 24

# If you have enabled USE_OPENMP and your application would call
# OpenBLAS's calculation API from multiple threads, please comment this in.
# This flag defines how many instances of OpenBLAS's calculation API can actually
# run in parallel. If more than NUM_PARALLEL threads call OpenBLAS's calculation API,
# they need to wait for the preceding API calls to finish or risk data corruption.
# NUM_PARALLEL = 2

# When multithreading, OpenBLAS needs to use a memory buffer for communicating
# and collating results for individual subranges of the original matrix. Since
# the original GotoBLAS of the early 2000s, the default size of this buffer has
# been set at a value of 32<<20 (which is 32MB) on x86_64 , twice that on PPC.
# If you expect to handle large problem sizes (beyond about 30000x30000) uncomment
# this line and adjust the (32<<n) factor if necessary. Usually an insufficient value
# manifests itself as a crash in the relevant scal kernel (sscal_k, dscal_k etc) 
# BUFFERSIZE = 25

# If you don't need to install the static library, please comment this in.
# NO_STATIC = 1

# If you don't need to generate the shared library, please comment this in.
# NO_SHARED = 1

# If you don't need the CBLAS interface, please comment this in.
# NO_CBLAS = 1

# If you only want the CBLAS interface without installing a Fortran compiler,
# please comment this in.
# ONLY_CBLAS = 1

# If you don't need LAPACK, please comment this in.
# If you set NO_LAPACK=1, the build system automatically sets NO_LAPACKE=1.
# NO_LAPACK = 1

# If you don't need LAPACKE (C Interface to LAPACK), please comment this in.
# NO_LAPACKE = 1

# Build LAPACK Deprecated functions since LAPACK 3.6.0
BUILD_LAPACK_DEPRECATED = 1

# Build RecursiveLAPACK on top of LAPACK
# BUILD_RELAPACK = 1
# Have RecursiveLAPACK actually replace standard LAPACK routines instead of 
# just adding its equivalents with a RELAPACK_ prefix
# RELAPACK_REPLACE = 1

# If you want to use the legacy threaded Level 3 implementation.
# USE_SIMPLE_THREADED_LEVEL3 = 1

# If you want to use the new, still somewhat experimental code that uses
# thread-local storage instead of a central memory buffer in memory.c
# Note that if your system uses GLIBC, it needs to have at least glibc 2.21
# for this to work.
# USE_TLS = 1

# If you want to drive whole 64bit region by BLAS. Not all Fortran
# compilers support this. It's safe to keep this commented out if you
# are not sure. (This is equivalent to the "-i8" ifort option).
# INTERFACE64 = 1

# Unfortunately most of kernel won't give us high quality buffer.
# BLAS tries to find the best region before entering main function,
# but it will consume time. If you don't like it, you can disable one.
NO_WARMUP = 1

# Comment this in if you want to disable OpenBLAS's CPU/Memory affinity handling.
# This feature is only implemented on Linux, and is always disabled on other platforms.
# Enabling affinity handling may improve performance, especially on NUMA systems, but 
# it may conflict with certain applications that also try to manage affinity.
# This conflict can result in threads of the application calling OpenBLAS ending up locked
# to the same core(s) as OpenBLAS, possibly binding all threads to a single core.
# For this reason, affinity handling is disabled by default. Can be safely enabled if nothing
# else modifies affinity settings.
# Note: enabling affinity has been known to cause problems with NumPy and R
NO_AFFINITY = 1

# If you are compiling for Linux and you have more than 16 numa nodes or more than 256 cpus
# BIGNUMA = 1

# If you are compiling for an embedded system ("bare metal") like Cortex M series
# Note that you will have to provide implementations of malloc() and free() in this case
# EMBEDDED = 1

# Don't use AVX kernel on Sandy Bridge. It is compatible with old compilers
# and OS. However, the performance is low.
# NO_AVX = 1

# Don't use Haswell optimizations if binutils is too old (e.g. RHEL6)
# NO_AVX2 = 1

# Don't use SkylakeX optimizations if binutils or compiler are too old (the build
# system will try to determine this automatically)
# NO_AVX512 = 1

# Don't use parallel make.
# NO_PARALLEL_MAKE = 1

# Force number of make jobs. The default is the number of logical CPU of the host.
# This is particularly useful when using distcc.
# A negative value will disable adding a -j flag to make, allowing to use a parent
# make -j value. This is useful to call OpenBLAS make from an other project
# makefile
# MAKE_NB_JOBS = 2

# If you would like to know minute performance report of GotoBLAS.
# FUNCTION_PROFILE = 1

# Support for IEEE quad precision(it's *real* REAL*16)( under testing)
# This option should not be used - it is a holdover from unfinished code present
# in the original GotoBLAS2 library that may be usable as a starting point but
# is not even expected to compile in its present form.
# QUAD_PRECISION = 1

# Theads are still working for a while after finishing BLAS operation
# to reduce thread activate/deactivate overhead. You can determine
# time out to improve performance. This number should be from 4 to 30
# which corresponds to (1 << n) cycles. For example, if you set to 26,
# thread will be running for (1 << 26) cycles(about 25ms on 3.0GHz
# system). Also you can control this number by THREAD_TIMEOUT
# CCOMMON_OPT	+= -DTHREAD_TIMEOUT=26

# Using special device driver for mapping physically contiguous memory
# to the user space. If bigphysarea is enabled, it will use it.
# DEVICEDRIVER_ALLOCATION = 1

# Use large page allocation (called hugepage support in Linux context)
# for the thread buffers (with access by shared memory operations)
# HUGETLB_ALLOCATION = 1

# Use large page allocation called hugepages in Linux) based on mmap accessing
# a memory-backed pseudofile (requires hugetlbfs to be mounted in the system,
# the example below has it mounted on /hugepages. OpenBLAS will create the backing
# file as gotoblas.processid in that path)
# HUGETLBFILE_ALLOCATION = /hugepages

# If you need to synchronize FP CSR between threads (for x86/x86_64 and aarch64 only).
# CONSISTENT_FPCSR = 1

# If any gemm argument m, n or k is less or equal this threshold, gemm will be execute
# with single thread. (Actually in recent versions this is a factor proportional to the
# number of floating point operations necessary for the given problem size, no longer
# an individual dimension). You can use this setting to avoid the overhead of multi-
# threading in small matrix sizes. The default value is 4, but values as high as 50 have 
# been reported to be optimal for certain workloads (50 is the recommended value for Julia).
# GEMM_MULTITHREAD_THRESHOLD = 4

# If you need sanity check by comparing results to reference BLAS. It'll be very
# slow (Not implemented yet).
# SANITY_CHECK = 1

# The installation directory.
# PREFIX = /opt/OpenBLAS

# Common Optimization Flag;
# The default -O2 is enough.
# Flags for POWER8 are defined in Makefile.power. Don't modify COMMON_OPT
# COMMON_OPT = -O2

# gfortran option for LAPACK to improve thread-safety
# It is enabled by default in Makefile.system for gfortran
# Flags for POWER8 are defined in Makefile.power. Don't modify FCOMMON_OPT
# FCOMMON_OPT = -frecursive

# Profiling flags
COMMON_PROF = -pg

# Build Debug version
# DEBUG = 1

# Set maximum stack allocation.
# The default value is 2048. 0 disable stack allocation a may reduce GER and GEMV
# performance. For details, https://github.com/xianyi/OpenBLAS/pull/482
#
# MAX_STACK_ALLOC = 0

# Add a prefix or suffix to all exported symbol names in the shared library.
# Avoid conflicts with other BLAS libraries, especially when using
# 64 bit integer interfaces in OpenBLAS.
# For details, https://github.com/xianyi/OpenBLAS/pull/459
#
# The same prefix and suffix are also added to the library name,
# i.e. you get lib$(SYMBOLPREFIX)openblas$(SYMBOLSUFFIX) rather than libopenblas
#
# SYMBOLPREFIX=
# SYMBOLSUFFIX=

# Run a C++ based thread safety tester after the build is done.
# This is mostly intended as a developer feature to spot regressions, but users and
# package maintainers can enable this if they have doubts about the thread safety of
# the library, given the configuration in this file.
# By default, the thread safety tester launches 52 concurrent calculations at the same
# time.
#
# Please note that the test uses ~1300 MiB of RAM for the DGEMM test.
#
# The test requires CBLAS to be built, a C++11 capable compiler and the presence of
# an OpenMP implementation. If you are cross-compiling this test will probably not
# work at all.
#
# CPP_THREAD_SAFETY_TEST = 1
#
# use this to run only the less memory-hungry GEMV test
# CPP_THREAD_SAFETY_GEMV = 1


# If you want to enable the experimental BFLOAT16 support
# BUILD_BFLOAT16 = 1


# Set the thread number threshold beyond which the job array for the threaded level3 BLAS
# will be allocated on the heap rather than the stack. (This array alone requires 
# NUM_THREADS*NUM_THREADS*128 bytes of memory so should not pose a problem at low cpu
# counts, but obviously it is not the only item that ends up on the stack.
# The default value of 32 ensures that the overall requirement is compatible
# with the default 1MB stacksize imposed by having the Java VM loaded without use
# of its -Xss parameter.
# The value of 160 formerly used from about version 0.2.7 until 0.3.10 is easily compatible
# with the common Linux stacksize of 8MB but will cause crashes with unwary use of the java
# VM e.g. in Octave or with the java-based libhdfs in numpy or scipy code
# BLAS3_MEM_ALLOC_THRESHOLD = 160



# By default the library contains BLAS functions (and LAPACK if selected) for all input types.
# To build a smaller library supporting e.g. only single precision real (SGEMM etc.) or only
# the functions for complex numbers, uncomment the desired type(s) below
# BUILD_SINGLE = 1
# BUILD_DOUBLE = 1
# BUILD_COMPLEX = 1
# BUILD_COMPLEX16 = 1
#
#  End of user configuration
#

```
File: Makefile
```
TOPDIR	= .
include ./Makefile.system
LNCMD = ln -fs
ifeq ($(FIXED_LIBNAME), 1)
LNCMD = true
endif

BLASDIRS = interface driver/level2 driver/level3 driver/others

ifneq ($(DYNAMIC_ARCH), 1)
BLASDIRS += kernel
endif

ifdef SANITY_CHECK
BLASDIRS += reference
endif

SUBDIRS	= $(BLASDIRS)
ifneq ($(NO_LAPACK), 1)
SUBDIRS	+= lapack
endif

RELA =
ifeq ($(BUILD_RELAPACK), 1)
RELA = re_lapack
endif

ifeq ($(NO_FORTRAN), 1)
define NOFORTRAN
1
endef
ifneq ($(NO_LAPACK), 1)
define C_LAPACK
1
endef
endif
export NOFORTRAN
export NO_LAPACK
export C_LAPACK
endif

ifeq ($(F_COMPILER),CRAY)
LAPACK_NOOPT := $(filter-out -O0 -O1 -O2 -O3 -Ofast -Og -Os,$(LAPACK_FFLAGS))
else
LAPACK_NOOPT := $(filter-out -O0 -O1 -O2 -O3 -Ofast -O -Og -Os,$(LAPACK_FFLAGS))
endif

SUBDIRS_ALL = $(SUBDIRS) test ctest utest exports benchmark ../laswp ../bench cpp_thread_test

.PHONY : all libs netlib $(RELA) test ctest shared install
.NOTPARALLEL : shared

all :: tests
	@echo
	@echo " OpenBLAS build complete. ($(LIB_COMPONENTS))"
	@echo
	@echo "  OS               ... $(OSNAME)             "
	@echo "  Architecture     ... $(ARCH)               "
ifndef BINARY64
	@echo "  BINARY           ... 32bit                 "
else
	@echo "  BINARY           ... 64bit                 "
endif

ifdef INTERFACE64
ifneq ($(INTERFACE64), 0)
	@echo "  Use 64 bits int    (equivalent to \"-i8\" in Fortran)      "
endif
endif
	@$(CC) --version > /dev/null 2>&1;\
	if [ $$? -eq 0 ]; then \
	   cverinfo=`$(CC) --version | sed -n '1p'`; \
	   if [ -z "$${cverinfo}" ]; then \
	   cverinfo=`$(CC) --version | sed -n '2p'`; \
	   fi; \
	   echo "  C compiler       ... $(C_COMPILER)  (cmd & version : $${cverinfo})";\
	else  \
	   echo "  C compiler       ... $(C_COMPILER)  (command line : $(CC))";\
	fi
ifeq ($(NOFORTRAN), $(filter 0,$(NOFORTRAN)))
	@$(FC) --version > /dev/null 2>&1;\
	if [ $$? -eq 0 ]; then \
	   fverinfo=`$(FC) --version | sed -n '1p'`; \
	   if [ -z "$${fverinfo}" ]; then \
	   fverinfo=`$(FC) --version | sed -n '2p'`; \
	   fi; \
	   echo "  Fortran compiler ... $(F_COMPILER)  (cmd & version : $${fverinfo})";\
	else \
	   echo "  Fortran compiler ... $(F_COMPILER)  (command line : $(FC))";\
	fi
endif
ifneq ($(OSNAME), AIX)
	@echo -n "  Library Name     ... $(LIBNAME)"
else
	@echo "  Library Name     ... $(LIBNAME)"
endif

ifndef SMP
	@echo " (Single-threading)  "
else
	@echo " (Multi-threading; Max num-threads is $(NUM_THREADS))"
endif

ifeq ($(DYNAMIC_ARCH), 1)
	@echo "  Supporting multiple $(ARCH) cpu models with minimum requirement for the common code being $(CORE)"
endif

ifeq ($(USE_OPENMP), 1)
	@echo
	@echo " Use OpenMP in the multithreading. Because of ignoring OPENBLAS_NUM_THREADS and GOTO_NUM_THREADS flags, "
	@echo " you should use OMP_NUM_THREADS environment variable to control the number of threads."
	@echo
endif

ifeq ($(OSNAME), Darwin)
	@echo "WARNING: If you plan to use the dynamic library $(LIBDYNNAME), you must run:"
	@echo
	@echo "\"make PREFIX=/your_installation_path/ install\"."
	@echo
	@echo "(or set PREFIX in Makefile.rule and run make install."
	@echo
	@echo "Note that any flags passed to make during build should also be passed to make install"
	@echo "to circumvent any install errors."
	@echo
	@echo "If you want to move the .dylib to a new location later, make sure you change"
	@echo "the internal name of the dylib with:"
	@echo
	@echo "install_name_tool -id /new/absolute/path/to/$(LIBDYNNAME) $(LIBDYNNAME)"
endif
	@echo
	@echo "To install the library, you can run \"make PREFIX=/path/to/your/installation install\"."
	@echo
	@echo "Note that any flags passed to make during build should also be passed to make install"
	@echo "to circumvent any install errors."
	@echo

shared : libs netlib $(RELA)
ifneq ($(NO_SHARED), 1)
ifeq ($(OSNAME), $(filter $(OSNAME),Linux SunOS Android Haiku FreeBSD DragonFly))
	@$(MAKE) -C exports so
	@$(LNCMD) $(LIBSONAME) $(LIBPREFIX).so
	@$(LNCMD) $(LIBSONAME) $(LIBPREFIX).so.$(MAJOR_VERSION)
endif
ifeq ($(OSNAME), $(filter $(OSNAME),OpenBSD NetBSD))
	@$(MAKE) -C exports so
	@$(LNCMD) $(LIBSONAME) $(LIBPREFIX).so
endif
ifeq ($(OSNAME), Darwin)
	@$(MAKE) -C exports dyn
	@$(LNCMD) $(LIBDYNNAME) $(LIBPREFIX).dylib
	@$(LNCMD) $(LIBDYNNAME) $(LIBPREFIX).$(MAJOR_VERSION).dylib
endif
ifeq ($(OSNAME), WINNT)
	@$(MAKE) -C exports dll
endif
ifeq ($(OSNAME), CYGWIN_NT)
	@$(MAKE) -C exports dll
endif
ifeq ($(OSNAME), AIX)
	@$(MAKE) -C exports so
endif
endif

tests : shared
ifeq ($(NOFORTRAN), $(filter 0,$(NOFORTRAN)))
	touch $(LIBNAME)
ifndef NO_FBLAS
	$(MAKE) -C test all
endif
endif
ifneq ($(ONLY_CBLAS), 1)
	$(MAKE) -C utest all
endif
ifneq ($(NO_CBLAS), 1)
ifneq ($(ONLY_CBLAS), 1)
	$(MAKE) -C ctest all
endif
ifeq ($(CPP_THREAD_SAFETY_TEST), 1)
	$(MAKE) -C cpp_thread_test all
endif
endif

libs :
ifeq ($(CORE), UNKNOWN)
	$(error OpenBLAS: Detecting CPU failed. Please set TARGET explicitly, e.g. make TARGET=your_cpu_target. Please read README for the detail.)
endif
ifeq ($(NOFORTRAN), 1)
	$(info OpenBLAS: Detecting fortran compiler failed. Can only compile BLAS and f2c-converted LAPACK.)
endif
ifeq ($(NO_STATIC), 1)
ifeq ($(NO_SHARED), 1)
	$(error OpenBLAS: neither static nor shared are enabled.)
endif
endif
	@for d in $(SUBDIRS) ; \
	do if test -d $$d; then \
	  $(MAKE) -C $$d $(@F) || exit 1 ; \
	fi; \
	done
#Save the config files for installation
	@cp Makefile.conf Makefile.conf_last
	@cp config.h config_last.h
ifdef QUAD_PRECISION
	@echo "#define QUAD_PRECISION">> config_last.h
endif
ifeq ($(EXPRECISION), 1)
	@echo "#define EXPRECISION">> config_last.h
endif
##
ifeq ($(DYNAMIC_ARCH), 1)
	@$(MAKE) -C kernel commonlibs || exit 1
	@for d in $(DYNAMIC_CORE) ; \
	do  $(MAKE) GOTOBLAS_MAKEFILE= -C kernel TARGET_CORE=$$d kernel || exit 1 ;\
	done
	@echo DYNAMIC_ARCH=1 >> Makefile.conf_last
ifeq ($(DYNAMIC_OLDER), 1)
	@echo DYNAMIC_OLDER=1 >> Makefile.conf_last
endif	
endif
	@echo TARGET=$(CORE) >> Makefile.conf_last
ifdef USE_THREAD
	@echo USE_THREAD=$(USE_THREAD) >>  Makefile.conf_last
endif
ifdef SMP
ifdef NUM_THREADS
	@echo NUM_THREADS=$(NUM_THREADS) >>  Makefile.conf_last
else
	@echo NUM_THREADS=$(NUM_CORES) >>  Makefile.conf_last
endif
endif
ifeq ($(USE_OPENMP),1)
	@echo USE_OPENMP=1 >>  Makefile.conf_last
endif
ifeq ($(INTERFACE64),1)
	@echo INTERFACE64=1 >>  Makefile.conf_last
endif
	@echo THELIBNAME=$(LIBNAME) >>  Makefile.conf_last
	@echo THELIBSONAME=$(LIBSONAME) >>  Makefile.conf_last
	@-$(LNCMD) $(LIBNAME) $(LIBPREFIX).$(LIBSUFFIX)
	@touch lib.grd

prof : prof_blas prof_lapack

prof_blas :
	$(LNCMD) $(LIBNAME_P) $(LIBPREFIX)_p.$(LIBSUFFIX)
	for d in $(SUBDIRS) ; \
	do if test -d $$d; then \
	  $(MAKE) -C $$d prof || exit 1 ; \
	fi; \
	done
ifeq ($(DYNAMIC_ARCH), 1)
	  $(MAKE) -C kernel commonprof || exit 1
endif

blas :
	$(LNCMD) $(LIBNAME) $(LIBPREFIX).$(LIBSUFFIX)
	for d in $(BLASDIRS) ; \
	do if test -d $$d; then \
	  $(MAKE) -C $$d libs || exit 1 ; \
	fi; \
	done

hpl :
	$(LNCMD) $(LIBNAME) $(LIBPREFIX).$(LIBSUFFIX)
	for d in $(BLASDIRS) ../laswp exports ; \
	do if test -d $$d; then \
	  $(MAKE) -C $$d $(@F) || exit 1 ; \
	fi; \
	done
ifeq ($(DYNAMIC_ARCH), 1)
	  $(MAKE) -C kernel commonlibs || exit 1
	for d in $(DYNAMIC_CORE) ; \
	do  $(MAKE) GOTOBLAS_MAKEFILE= -C kernel TARGET_CORE=$$d kernel || exit 1 ;\
	done
endif

hpl_p :
	$(LNCMD) $(LIBNAME_P) $(LIBPREFIX)_p.$(LIBSUFFIX)
	for d in $(SUBDIRS) ../laswp exports ; \
	do if test -d $$d; then \
	  $(MAKE) -C $$d $(@F) || exit 1 ; \
	fi; \
	done

netlib : lapack_prebuild
ifneq ($(NO_LAPACK), 1)
	@$(MAKE) -C $(NETLIB_LAPACK_DIR) lapacklib
	@$(MAKE) -C $(NETLIB_LAPACK_DIR) tmglib
endif
ifneq ($(NO_LAPACKE), 1)
	@$(MAKE) -C $(NETLIB_LAPACK_DIR) lapackelib
endif

ifeq ($(NO_LAPACK), 1)
re_lapack :

else
re_lapack :
	@$(MAKE) -C relapack
endif

prof_lapack : lapack_prebuild
	@$(MAKE) -C $(NETLIB_LAPACK_DIR) lapack_prof

lapack_prebuild :
ifeq ($(NO_LAPACK), $(filter 0,$(NO_LAPACK)))
	-@echo "FC          = $(FC)" > $(NETLIB_LAPACK_DIR)/make.inc
ifeq ($(F_COMPILER), GFORTRAN)
	-@echo "override FFLAGS      = $(LAPACK_FFLAGS) -fno-tree-vectorize" >> $(NETLIB_LAPACK_DIR)/make.inc
else
	-@echo "override FFLAGS      = $(LAPACK_FFLAGS)" >> $(NETLIB_LAPACK_DIR)/make.inc
endif
	-@echo "FFLAGS_DRV  = $(LAPACK_FFLAGS)" >> $(NETLIB_LAPACK_DIR)/make.inc
	-@echo "POPTS       = $(LAPACK_FPFLAGS)" >> $(NETLIB_LAPACK_DIR)/make.inc
	-@echo "FFLAGS_NOOPT       = -O0 $(LAPACK_NOOPT)" >> $(NETLIB_LAPACK_DIR)/make.inc
	-@echo "PNOOPT      = $(LAPACK_FPFLAGS) -O0" >> $(NETLIB_LAPACK_DIR)/make.inc
ifeq ($(C_COMPILER)$(F_COMPILER)$(USE_OPENMP), CLANGGFORTRAN1)
	-@echo "LDFLAGS     = $(FFLAGS) $(EXTRALIB) -lomp" >> $(NETLIB_LAPACK_DIR)/make.inc
else
ifeq ($(C_COMPILER)$(F_COMPILER)$(USE_OPENMP), CLANGIBM1)
	-@echo "LDFLAGS     = $(FFLAGS) $(EXTRALIB) -lomp" >> $(NETLIB_LAPACK_DIR)/make.inc
else
	-@echo "LDFLAGS     = $(FFLAGS) $(EXTRALIB)" >> $(NETLIB_LAPACK_DIR)/make.inc
endif
endif
	-@echo "CC          = $(CC)" >> $(NETLIB_LAPACK_DIR)/make.inc
	-@echo "override CFLAGS      = $(LAPACK_CFLAGS)" >> $(NETLIB_LAPACK_DIR)/make.inc
	-@echo "AR          = $(AR)" >> $(NETLIB_LAPACK_DIR)/make.inc
	-@echo "ARFLAGS     = $(ARFLAGS) -ru" >> $(NETLIB_LAPACK_DIR)/make.inc
	-@echo "RANLIB      = $(RANLIB)" >> $(NETLIB_LAPACK_DIR)/make.inc
	-@echo "LAPACKLIB   = ../../$(LIBNAME)" >> $(NETLIB_LAPACK_DIR)/make.inc
	-@echo "TMGLIB      = ../../../$(LIBNAME)" >> $(NETLIB_LAPACK_DIR)/make.inc
	-@echo "BLASLIB     = ../../../$(LIBNAME)" >> $(NETLIB_LAPACK_DIR)/make.inc
	-@echo "LAPACKELIB  = ../../../$(LIBNAME)" >> $(NETLIB_LAPACK_DIR)/make.inc
	-@echo "LAPACKLIB_P = ../$(LIBNAME_P)" >> $(NETLIB_LAPACK_DIR)/make.inc
	-@echo "SUFFIX      = $(SUFFIX)" >> $(NETLIB_LAPACK_DIR)/make.inc
	-@echo "PSUFFIX     = $(PSUFFIX)" >> $(NETLIB_LAPACK_DIR)/make.inc
	-@echo "CEXTRALIB   = $(EXTRALIB)" >> $(NETLIB_LAPACK_DIR)/make.inc
ifeq ($(F_COMPILER), GFORTRAN)
	-@echo "TIMER       = INT_ETIME" >> $(NETLIB_LAPACK_DIR)/make.inc
ifdef SMP
ifeq ($(OSNAME), WINNT)
	-@echo "LOADER      = $(FC)" >> $(NETLIB_LAPACK_DIR)/make.inc
else ifeq ($(OSNAME), Haiku)
	-@echo "LOADER      = $(FC)" >> $(NETLIB_LAPACK_DIR)/make.inc
else
	-@echo "LOADER      = $(FC) -pthread" >> $(NETLIB_LAPACK_DIR)/make.inc
endif
else
	-@echo "LOADER      = $(FC)" >> $(NETLIB_LAPACK_DIR)/make.inc
endif
else
	-@echo "TIMER       = NONE" >> $(NETLIB_LAPACK_DIR)/make.inc
	-@echo "LOADER      = $(FC)" >> $(NETLIB_LAPACK_DIR)/make.inc
endif
ifeq ($(BUILD_LAPACK_DEPRECATED), 1)
	-@echo "BUILD_DEPRECATED      = 1" >> $(NETLIB_LAPACK_DIR)/make.inc
endif
ifeq ($(BUILD_SINGLE), 1)
	-@echo "BUILD_SINGLE      = 1" >> $(NETLIB_LAPACK_DIR)/make.inc
endif
ifeq ($(BUILD_DOUBLE), 1)
	-@echo "BUILD_DOUBLE      = 1" >> $(NETLIB_LAPACK_DIR)/make.inc
endif
ifeq ($(BUILD_COMPLEX), 1)
	-@echo "BUILD_COMPLEX      = 1" >> $(NETLIB_LAPACK_DIR)/make.inc
endif
ifeq ($(BUILD_COMPLEX16), 1)
	-@echo "BUILD_COMPLEX16      = 1" >> $(NETLIB_LAPACK_DIR)/make.inc
endif
	-@echo "LAPACKE_WITH_TMG      = 1" >> $(NETLIB_LAPACK_DIR)/make.inc
	-@cat  make.inc >> $(NETLIB_LAPACK_DIR)/make.inc
endif

large.tgz :
ifeq ($(NOFORTRAN), $(filter 0,$(NOFORTRAN)))
	if [ ! -a $< ]; then
	-wget http://www.netlib.org/lapack/timing/large.tgz;
	fi
endif

timing.tgz :
ifeq ($(NOFORTRAN), $(filter 0,$(NOFORTRAN)))
	if [ ! -a $< ]; then
	-wget http://www.netlib.org/lapack/timing/timing.tgz;
	fi
endif

lapack-timing : large.tgz timing.tgz
ifeq ($(NOFORTRAN), $(filter 0,$(NOFORTRAN)))
	(cd $(NETLIB_LAPACK_DIR); $(TAR) zxf ../timing.tgz TIMING)
	(cd $(NETLIB_LAPACK_DIR)/TIMING; $(TAR) zxf ../../large.tgz )
	$(MAKE) -C $(NETLIB_LAPACK_DIR)/TIMING
endif


lapack-test :
	(cd $(NETLIB_LAPACK_DIR)/TESTING && rm -f x* *.out)
	$(MAKE) -j 1 -C $(NETLIB_LAPACK_DIR)/TESTING/EIG xeigtstc  xeigtstd  xeigtsts  xeigtstz 
	$(MAKE) -j 1 -C $(NETLIB_LAPACK_DIR)/TESTING/LIN xlintstc  xlintstd  xlintstds  xlintstrfd  xlintstrfz  xlintsts  xlintstz  xlintstzc xlintstrfs xlintstrfc
ifneq ($(CROSS), 1)
	( cd $(NETLIB_LAPACK_DIR)/INSTALL; $(MAKE) all; ./testlsame; ./testslamch; ./testdlamch; \
        ./testsecond; ./testdsecnd; ./testieee; ./testversion )
	(cd $(NETLIB_LAPACK_DIR); ./lapack_testing.py -r -b TESTING)
endif

lapack-runtest: lapack-test
	( cd $(NETLIB_LAPACK_DIR)/INSTALL; ./testlsame; ./testslamch; ./testdlamch; \
        ./testsecond; ./testdsecnd; ./testieee; ./testversion )
	(cd $(NETLIB_LAPACK_DIR); ./lapack_testing.py -r -b TESTING )


blas-test:
	(cd $(NETLIB_LAPACK_DIR)/BLAS/TESTING && rm -f x* *.out)

	$(MAKE) -j 1 -C $(NETLIB_LAPACK_DIR) blas_testing
	(cd $(NETLIB_LAPACK_DIR)/BLAS/TESTING && cat *.out)


dummy :

install :
	$(MAKE) -f Makefile.install install

clean ::
	@for d in $(SUBDIRS_ALL) ; \
	do if test -d $$d; then \
	  $(MAKE) -C $$d $(@F) || exit 1 ; \
	fi; \
	done
#ifdef DYNAMIC_ARCH
	@$(MAKE) -C kernel clean
#endif
	@$(MAKE) -C reference clean
	@rm -f *.$(LIBSUFFIX) *.so *~ *.exe getarch getarch_2nd *.dll *.lib *.$(SUFFIX) *.dwf $(LIBPREFIX).$(LIBSUFFIX) $(LIBPREFIX)_p.$(LIBSUFFIX) $(LIBPREFIX).so.$(MAJOR_VERSION) *.lnk myconfig.h *.so.renamed *.a.renamed *.so.0
ifeq ($(OSNAME), Darwin)
	@rm -rf getarch.dSYM getarch_2nd.dSYM
endif
	@rm -f Makefile.conf config.h Makefile_kernel.conf config_kernel.h st* *.dylib
	@rm -f cblas.tmp cblas.tmp2
	@touch $(NETLIB_LAPACK_DIR)/make.inc
	@$(MAKE) -C $(NETLIB_LAPACK_DIR) clean
	@rm -f $(NETLIB_LAPACK_DIR)/make.inc $(NETLIB_LAPACK_DIR)/lapacke/include/lapacke_mangling.h
	@$(MAKE) -C relapack clean
	@rm -f *.grd Makefile.conf_last config_last.h
	@(cd $(NETLIB_LAPACK_DIR)/TESTING && rm -f x* *.out testing_results.txt)
	@echo Done.

```
File: GotoBLAS_02QuickInstall.txt
```
                Quick installation for GotoBLAS2

***************************************************************************
***************************************************************************
**                                                                       **
**                                                                       **
**                    Just type "make" <<return>>.                       **
**                                                                       **
**           If you're not satisfied with this library,                  **
**           please read following instruction and customize it.         **
**                                                                       **
**                                                                       **
***************************************************************************
***************************************************************************


1. REALLY REALLY quick way to build library

    Type "make" or "gmake".

   $shell> make

   The script will detect Fortran compiler, number of cores and
   architecture which you're using. If default gcc binary type is
   64bit, 64 bit library will be created. Otherwise 32 bit library
   will be created.

   After finishing compile, you'll find various information about
   generated library.

 =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

 GotoBLAS2 build complete.

  OS               ... Linux
  Architecture     ... x86_64
  BINARY           ... 64bit
  C compiler       ... GCC  (command line : gcc)
  Fortran compiler ... PATHSCALE  (command line : pathf90)
  Library Name     ... libgoto_barcelonap-r1.27.a (Multi threaded; Max
  num-threads is 16)

 =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


2. Specifying 32bit or 64bit library

   If you need 32bit binary,

   $shell> make BINARY=32

   If you need 64bit binary,

   $shell> make BINARY=64


3. Specifying target architecture

   If you need library for different architecture, you can use TARGET
   option. You can find current available options in top of getarch.c.
   For example, if you need library for Intel core2 architecture,
   you'll find FORCE_CORE2 option in getarch.c. Therefore you can
   specify TARGET=CORE2 (get rid of FORCE_) with make.

   $shell> make TARGET=CORE2

   Also if you want GotoBLAS2 to support multiple architecture,

   $shell> make DYNAMIC_ARCH=1

   All kernel will be included in the library and dynamically switched
   the best architecutre at run time.


4. Specifying for enabling multi-threaded

   Script will detect number of cores and will enable multi threaded
   library if number of cores is more than two. If you still want to
   create single threaded library,

   $shell> make USE_THREAD=0

   Or if you need threaded library by force,

   $shell> make USE_THREAD=1


5. Specifying target OS

   Target architecture will be determined by the CC. If you
   specify cross compiler for MIPS, you can create library for
   MIPS architecture.

   $shell> make CC=mips64el-linux-gcc TARGET=SICORTEX

   Or you can specify your favorite C compiler with absolute path.

   $shell> make CC=/opt/intel/cc/32/10.0.026/bin/icc TARGET=BARCELONA

   Binary type (32bit/64bit) is determined by checking CC, you
   can control binary type with this option.

   $shell> make CC="pathcc -m32"

   In this case, 32bit library will be created.


6. Specifying Fortran compiler

   If you need to support other Fortran compiler, you can specify with
   FC option.

   $shell> make FC=gfortran


7. Other useful options

   You'll find other useful options in Makefile.rule.

```
File: GotoBLAS_01Readme.txt
```
              Optimized GotoBLAS2 libraries version 1.13

                       By Kazushige Goto <kgoto@tacc.utexas.edu>

# This is the last update and done on 5th Feb. 2010.

0. License

   See 00TACC_Research_License.txt.

1. Supported OS

     Linux
     FreeBSD(Also it may work on NetBSD)
     OSX
     Soralis
     Windows 2k, XP, Server 2003 and 2008(both 32bit and 64bit)
     AIX
     Tru64 UNIX

2. Supported Architecture

    X86  : Pentium3 Katmai
                    Coppermine
           Athlon  (not well optimized, though)
           PentiumM Banias, Yonah
           Pentium4 Northwood
                    Nocona (Prescott)
	   Core 2   Woodcrest
	   Core 2   Penryn
           Nehalem-EP  Corei{3,5,7}
	   Atom
           AMD Opteron
	   AMD Barlcelona, Shanghai, Istanbul
	   VIA NANO

   X86_64: Pentium4 Nocona
	   Core 2   Woodcrest
	   Core 2   Penryn
           Nehalem
	   Atom
           AMD Opteron
	   AMD Barlcelona, Shanghai, Istanbul
	   VIA NANO

   IA64  : Itanium2

   Alpha : EV4, EV5, EV6

   POWER : POWER4
           PPC970/PPC970FX
           PPC970MP
	   CELL (PPU only)
           POWER5
           PPC440   (QCDOC)
           PPC440FP2(BG/L)
	   POWERPC G4(PPC7450)
           POWER6

   SPARC : SPARC IV
           SPARC VI, VII (Fujitsu chip)

   MIPS64/32: Sicortex

3. Supported compiler

   C compiler       : GNU CC
                      Cygwin, MinGW
                      Other commercial compiler(especially for x86/x86_64)

   Fortran Compiler : GNU G77, GFORTRAN
		      G95
		      Open64
                      Compaq
                      F2C
                      IBM
                      Intel
                      PathScale
                      PGI
                      SUN
                      Fujitsu

4. Supported precision

 Now x86/x86_64 version support 80bit FP precision in addition to
normal double presicion and single precision. Currently only
gfortran supports 80bit FP with "REAL*10".


5. How to build library?

 Please see 02QuickInstall.txt or just type "make".


```
File: .cirrus.yml
```
macos_instance:
  image: ghcr.io/cirruslabs/macos-monterey-xcode:latest

#task:
#  name: AppleM1/LLVM
#  compile_script:
#  - brew install llvm
#  - export PATH=/opt/homebrew/opt/llvm/bin:$PATH
#  - export LDFLAGS="-L/opt/homebrew/opt/llvm/lib"
#  - export CPPFLAGS="-I/opt/homebrew/opt/llvm/include"
#  - make TARGET=VORTEX USE_OPENMP=1 CC=clang

#task:
#  name: AppleM1/LLVM/ILP64
#  compile_script:
#  - brew install llvm
#  - export PATH=/opt/homebrew/opt/llvm/bin:$PATH
#  - export LDFLAGS="-L/opt/homebrew/opt/llvm/lib"
#  - export CPPFLAGS="-I/opt/homebrew/opt/llvm/include"
#  - make TARGET=VORTEX USE_OPENMP=1 CC=clang INTERFACE64=1

#task:
#  name: AppleM1/LLVM/CMAKE
#  compile_script:
#  - brew install llvm
#  - export PATH=/opt/homebrew/opt/llvm/bin:$PATH
#  - export LDFLAGS="-L/opt/homebrew/opt/llvm/lib"
#  - export CPPFLAGS="-I/opt/homebrew/opt/llvm/include"
#  - mkdir build
#  - cd build
#  - cmake -DTARGET=VORTEX -DCMAKE_C_COMPILER=clang -DBUILD_SHARED_LIBS=ON ..
#  - make -j 4

#task:
#  name: AppleM1/GCC/MAKE/OPENMP
#  compile_script:
#  - brew install gcc@11
#  - export PATH=/opt/homebrew/bin:$PATH
#  - export LDFLAGS="-L/opt/homebrew/lib"
#  - export CPPFLAGS="-I/opt/homebrew/include"
#  - make CC=gcc-11 FC=gfortran-11 USE_OPENMP=1
  
macos_instance:
  image: ghcr.io/cirruslabs/macos-sonoma-xcode:latest
task:
  name: AppleM1/LLVM x86_64 xbuild
  compile_script:
  - #brew install llvm
  - export #PATH=/opt/homebrew/opt/llvm/bin:$PATH
  - export #LDFLAGS="-L/opt/homebrew/opt/llvm/lib"
  - export #CPPFLAGS="-I/opt/homebrew/opt/llvm/include" 
  - export ARCHS="i386 x86_64"
  - export ARCHS_STANDARD="i386 x86_64"
  - export ARCHS_STANDARD_32_64_BIT="i386 x86_64"
  - export ARCHS_STANDARD_64_BIT=x86_64
  - export ARCHS_STANDARD_INCLUDING_64_BIT="i386 x86_64"
  - export ARCHS_UNIVERSAL_IPHONE_OS="i386 x86_64"
  - export VALID_ARCHS="i386 x86_64"
  - xcrun --sdk macosx --show-sdk-path
  - xcodebuild -version
  - export CC=/Applications/Xcode_15.4.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang
  - export CFLAGS="-O2 -unwindlib=none -Wno-macro-redefined -isysroot /Applications/Xcode_15.4.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.5.sdk -arch x86_64"
  - make TARGET=CORE2 DYNAMIC_ARCH=1 NUM_THREADS=32 HOSTCC=clang NOFORTRAN=1 RANLIB="ls -l"
  always:
    config_artifacts:
      path: "*conf*"
      type: text/plain
#  lib_artifacts:
#    path: "libopenblas*"
#    type: application/octet-streamm

macos_instance:
  image: ghcr.io/cirruslabs/macos-sonoma-xcode:latest
task:
  name: AppleM1/LLVM armv8-ios xbuild
  compile_script:
  - #brew install llvm
  - export #PATH=/opt/homebrew/opt/llvm/bin:$PATH
  - export #LDFLAGS="-L/opt/homebrew/opt/llvm/lib"
  - export #CPPFLAGS="-I/opt/homebrew/opt/llvm/include" 
  - export CC=/Applications/Xcode_15.4.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang
  - export CFLAGS="-O2 -unwindlib=none -Wno-macro-redefined -isysroot /Applications/Xcode_15.4.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS17.5.sdk -arch arm64 -miphoneos-version-min=10.0"
  - xcrun --sdk iphoneos --show-sdk-path
  - ls -l /Applications
  - make TARGET=ARMV8 NUM_THREADS=32 HOSTCC=clang NOFORTRAN=1 CROSS=1
  always:
    config_artifacts:
      path: "*conf*"
      type: text/plain

macos_instance:
  image: ghcr.io/cirruslabs/macos-monterey-xcode:latest
task:
  name: AppleM1/LLVM armv7-androidndk xbuild
  compile_script:
  - brew install android-ndk
  - export #PATH=/opt/homebrew/opt/llvm/bin:$PATH
  - export #LDFLAGS="-L/opt/homebrew/opt/llvm/lib"
  - export #CPPFLAGS="-I/opt/homebrew/opt/llvm/include" 
  - ls /System/Volumes/Data/opt/homebrew
  - ls -l /System/Volumes/Data/opt/homebrew/Caskroom/android-ndk
  - find /System/Volumes/Data/opt/homebrew -name "armv7a-linux-androideabi*-ranlib"
  - #export CC=/Applications/Xcode-13.4.1.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang
  - #export CFLAGS="-O2 -unwindlib=none -Wno-macro-redefined -isysroot /Applications/Xcode-13.4.1.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS16.0.sdk -arch arm64 -miphoneos-version-min=10.0"
  - export CC=/System/Volumes/Data/opt/homebrew/Caskroom/android-ndk/26d/AndroidNDK*.app/Contents/NDK/toolchains/llvm/prebuilt/darwin-x86_64/bin/armv7a-linux-androideabi23-clang
  - make TARGET=ARMV7 ARM_SOFTFP_ABI=1 NUM_THREADS=32 HOSTCC=clang NOFORTRAN=1 RANLIB="ls -l"
  always:
    config_artifacts:
      path: "*conf*"
      type: text/plain

task:
  name: NeoverseN1
  arm_container:
    image: node:latest
  compile_script:
  - make

  task:
  name: NeoverseN1-ILP64
  arm_container:
    image: node:latest
  compile_script:
  - make INTERFACE64=1

task:
  name: NeoverseN1-OMP
  arm_container:
    image: node:latest
    cpu: 8
  compile_script:
  - make USE_OPENMP=1

FreeBSD_task:
  name: FreeBSD-gcc12
  freebsd_instance:
    image_family: freebsd-13-3
  install_script:
  - pkg update -f && pkg upgrade -y && pkg install -y gmake gcc
  compile_script:
  - ls -l /usr/local/lib
  - gmake CC=gcc 


FreeBSD_task:
  name: freebsd-gcc12-ilp64
  freebsd_instance:
    image_family: freebsd-13-3
  install_script:
  - pkg update -f && pkg upgrade -y && pkg install -y gmake gcc
  compile_script:
  - ls -l /usr/local/lib
  - gmake CC=gcc INTERFACE64=1

FreeBSD_task:
  name: FreeBSD-clang-openmp
  freebsd_instance:
    image_family: freebsd-13-3
  install_script:
  - pkg update -f && pkg upgrade -y && pkg install -y gmake gcc 
  - ln -s /usr/local/lib/gcc13/libgfortran.so.5.0.0 /usr/lib/libgfortran.so
  compile_script:
  - gmake CC=clang FC=gfortran USE_OPENMP=1 CPP_THREAD_SAFETY_TEST=1

#task:
#  name: Windows/LLVM16     --- too slow ---
#  windows_container:
#    image: cirrusci/windowsservercore:cmake-2021.12.07
#  install_script: 
#    - choco list --localonly
#    - choco install -y llvm
#    - # choco install -y cmake --installargs '"ADD_CMAKE_TO_PATH=System"'
#    - choco install -y ninja
#    - refreshenv
#    - cd "c:/Program Files (x86)/Microsoft Visual Studio/2019/BuildTools/VC/Auxiliary/Build"
#    - vcvarsall x64
#    - cd "C:\Users\ContainerAdministrator\AppData\Local\Temp\cirrus-ci-build"
#    - cmake -S . -B build -G "Ninja" -DCMAKE_CXX_COMPILER=clang-cl -DCMAKE_C_COMPILER=clang-cl -DCMAKE_MT=mt -DCMAKE_BUILD_TYPE=Release
#    - cd build
#    - cmake --build .
#    - ctest

```
File: quickbuild.32bit
```
#!/bin/bash

make -j 2 BINARY=32

```
File: Jenkinsfile
```
pipeline {
    agent { 
        docker {
            image 'osuosl/ubuntu-s390x'
        }
    }
    stages {
        stage('Build') {
            steps {
                sh 'make clean && make'
            }
        }
    }
}

```
File: Makefile.install
```
TOPDIR	= .
export GOTOBLAS_MAKEFILE = 1
-include $(TOPDIR)/Makefile.conf_last
include ./Makefile.system
LNCMD = ln -fs

ifdef THELIBNAME
LIBNAME=$(THELIBNAME)
LIBSONAME=$(THELIBSONAME)
endif
ifeq ($(FIXED_LIBNAME), 1)
LNCMD = true
endif
ifeq ($(INTERFACE64),1)
USE_64BITINT=1
endif

PREFIX ?= /opt/OpenBLAS

OPENBLAS_INCLUDE_DIR := $(PREFIX)/include
OPENBLAS_LIBRARY_DIR := $(PREFIX)/lib
OPENBLAS_BINARY_DIR := $(PREFIX)/bin
OPENBLAS_BUILD_DIR := $(CURDIR)
OPENBLAS_CMAKE_DIR := $(OPENBLAS_LIBRARY_DIR)/cmake/$(LIBSONAMEBASE)
OPENBLAS_CMAKE_CONFIG := OpenBLASConfig.cmake
OPENBLAS_CMAKE_CONFIG_VERSION := OpenBLASConfigVersion.cmake
OPENBLAS_PKGCONFIG_DIR := $(OPENBLAS_LIBRARY_DIR)/pkgconfig
PKG_EXTRALIB := $(EXTRALIB)
ifeq ($(INTERFACE64),1)
	SUFFIX64=64
endif
PKGFILE="$(DESTDIR)$(OPENBLAS_PKGCONFIG_DIR)/$(LIBSONAMEBASE)$(SUFFIX64).pc"

ifeq ($(USE_OPENMP), 1)
  ifeq ($(C_COMPILER), PGI)
          PKG_EXTRALIB += -lomp
  else	  
          PKG_EXTRALIB += -lgomp
  endif
endif	  

.PHONY : install
.NOTPARALLEL : install

lib.grd :
	$(error OpenBLAS: Please run "make" firstly)

install : 	lib.grd
	@-mkdir -p "$(DESTDIR)$(PREFIX)"
	@-mkdir -p "$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)"
	@-mkdir -p "$(DESTDIR)$(OPENBLAS_LIBRARY_DIR)"
	@-mkdir -p "$(DESTDIR)$(OPENBLAS_BINARY_DIR)"
	@-mkdir -p "$(DESTDIR)$(OPENBLAS_CMAKE_DIR)"
	@-mkdir -p "$(DESTDIR)$(OPENBLAS_PKGCONFIG_DIR)"
	@echo Generating openblas_config.h in $(DESTDIR)$(OPENBLAS_INCLUDE_DIR)
#for inc
	@echo \#ifndef OPENBLAS_CONFIG_H > "$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/openblas_config.h"
	@echo \#define OPENBLAS_CONFIG_H >> "$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/openblas_config.h"
	@$(AWK) 'NF {print $$1, "OPENBLAS_"$$2, $$3}' config_last.h >> "$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/openblas_config.h"
	@echo \#define OPENBLAS_VERSION \" OpenBLAS $(VERSION) \" >> "$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/openblas_config.h"
	@cat openblas_config_template.h >> "$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/openblas_config.h"
	@echo \#endif  \/\* OPENBLAS_CONFIG_H \*\/ >> "$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/openblas_config.h"

	@echo Generating f77blas.h in $(DESTDIR)$(OPENBLAS_INCLUDE_DIR)
	@echo \#ifndef OPENBLAS_F77BLAS_H > "$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/f77blas.h"
	@echo \#define OPENBLAS_F77BLAS_H >> "$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/f77blas.h"
	@echo \#include \"openblas_config.h\" >> "$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/f77blas.h"
	@cat common_interface.h >> "$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/f77blas.h"
	@echo \#endif >> "$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/f77blas.h"

ifndef NO_CBLAS
	@echo Generating cblas.h in $(DESTDIR)$(OPENBLAS_INCLUDE_DIR)
	@cp cblas.h cblas.tmp
ifdef SYMBOLPREFIX
	@sed 's/cblas[^( ]*/$(SYMBOLPREFIX)&/g' cblas.tmp > cblas.tmp2
	@sed 's/openblas[^( ]*/$(SYMBOLPREFIX)&/g'  cblas.tmp2 > cblas.tmp
	#change back any openblas_complex_float and double that got hit
	@sed 's/$(SYMBOLPREFIX)openblas_complex_/openblas_complex_/g'  cblas.tmp > cblas.tmp2
	@sed 's/goto[^( ]*/$(SYMBOLPREFIX)&/g'  cblas.tmp2 > cblas.tmp
endif
ifdef SYMBOLSUFFIX
	@sed 's/cblas[^( ]*/&$(SYMBOLSUFFIX)/g' cblas.tmp > cblas.tmp2
	@sed 's/openblas[^( ]*/&$(SYMBOLSUFFIX)/g'  cblas.tmp2 > cblas.tmp
	#change back any openblas_complex_float and double that got hit
	@sed 's/\(openblas_complex_\)\([^ ]*\)$(SYMBOLSUFFIX)/\1\2 /g'  cblas.tmp > cblas.tmp2
	@sed 's/goto[^( ]*/&$(SYMBOLSUFFIX)/g'  cblas.tmp2 > cblas.tmp
endif
	@sed 's/common/openblas_config/g' cblas.tmp > "$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/cblas.h"
endif

ifneq ($(OSNAME), AIX)
ifneq ($(NO_LAPACKE), 1)
	@echo Copying LAPACKE header files to $(DESTDIR)$(OPENBLAS_INCLUDE_DIR)
	@-install -m644 $(NETLIB_LAPACK_DIR)/LAPACKE/include/lapack.h "$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/lapack.h"
	@-install -m644 $(NETLIB_LAPACK_DIR)/LAPACKE/include/lapacke.h "$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/lapacke.h"
	@-install -m644 $(NETLIB_LAPACK_DIR)/LAPACKE/include/lapacke_config.h "$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/lapacke_config.h"
	@-install -m644 $(NETLIB_LAPACK_DIR)/LAPACKE/include/lapacke_mangling_with_flags.h.in "$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/lapacke_mangling.h"
	@-install -m644 $(NETLIB_LAPACK_DIR)/LAPACKE/include/lapacke_utils.h "$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/lapacke_utils.h"
endif

#for install static library
ifneq ($(NO_STATIC),1)
	@echo Copying the static library to $(DESTDIR)$(OPENBLAS_LIBRARY_DIR)
	@install -m644 $(LIBNAME) "$(DESTDIR)$(OPENBLAS_LIBRARY_DIR)"
	@cd "$(DESTDIR)$(OPENBLAS_LIBRARY_DIR)" ; \
	$(LNCMD) $(LIBNAME) $(LIBPREFIX).$(LIBSUFFIX)
endif
#for install shared library
ifneq ($(NO_SHARED),1)
	@echo Copying the shared library to $(DESTDIR)$(OPENBLAS_LIBRARY_DIR)
ifeq ($(OSNAME), $(filter $(OSNAME),Linux SunOS Android Haiku FreeBSD DragonFly))
	@install -m755 $(LIBSONAME) "$(DESTDIR)$(OPENBLAS_LIBRARY_DIR)"
	@cd "$(DESTDIR)$(OPENBLAS_LIBRARY_DIR)" ; \
	$(LNCMD) $(LIBSONAME) $(LIBPREFIX).so ; \
	$(LNCMD) $(LIBSONAME) $(LIBPREFIX).so.$(MAJOR_VERSION)
endif

ifeq ($(OSNAME), $(filter $(OSNAME),OpenBSD NetBSD))
	@cp $(LIBSONAME) "$(DESTDIR)$(OPENBLAS_LIBRARY_DIR)"
	@cd "$(DESTDIR)$(OPENBLAS_LIBRARY_DIR)" ; \
	$(LNCMD) $(LIBSONAME) $(LIBPREFIX).so
endif
ifeq ($(OSNAME), Darwin)
	@-cp $(LIBDYNNAME) "$(DESTDIR)$(OPENBLAS_LIBRARY_DIR)"
	@-install_name_tool -id "$(OPENBLAS_LIBRARY_DIR)/$(LIBPREFIX).$(MAJOR_VERSION).dylib" "$(DESTDIR)$(OPENBLAS_LIBRARY_DIR)/$(LIBDYNNAME)"
	@cd "$(DESTDIR)$(OPENBLAS_LIBRARY_DIR)" ; \
	$(LNCMD) $(LIBDYNNAME) $(LIBPREFIX).dylib ; \
	$(LNCMD) $(LIBDYNNAME) $(LIBPREFIX).$(MAJOR_VERSION).dylib
endif
ifeq ($(OSNAME), WINNT)
	@-cp $(LIBDLLNAME) "$(DESTDIR)$(OPENBLAS_BINARY_DIR)"
	@-cp $(IMPLIBNAME) "$(DESTDIR)$(OPENBLAS_LIBRARY_DIR)"
endif
ifeq ($(OSNAME), CYGWIN_NT)
	@-cp $(LIBDLLNAME) "$(DESTDIR)$(OPENBLAS_BINARY_DIR)"
	@-cp $(IMPLIBNAME) "$(DESTDIR)$(OPENBLAS_LIBRARY_DIR)"
endif
endif

else
#install on AIX has different options syntax
ifneq ($(NO_LAPACKE), 1)
	@echo Copying LAPACKE header files to $(DESTDIR)$(OPENBLAS_INCLUDE_DIR)
	@-installbsd -c -m 644 $(NETLIB_LAPACK_DIR)/LAPACKE/include/lapack.h "$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/lapack.h"
	@-installbsd -c -m 644 $(NETLIB_LAPACK_DIR)/LAPACKE/include/lapacke.h "$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/lapacke.h"
	@-installbsd -c -m 644 $(NETLIB_LAPACK_DIR)/LAPACKE/include/lapacke_config.h "$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/lapacke_config.h"
	@-installbsd -c -m 644 $(NETLIB_LAPACK_DIR)/LAPACKE/include/lapacke_mangling_with_flags.h.in "$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/lapacke_mangling.h"
	@-installbsd -c -m 644 $(NETLIB_LAPACK_DIR)/LAPACKE/include/lapacke_utils.h "$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/lapacke_utils.h"
endif

#for install static library
ifneq ($(NO_STATIC),1)
	@echo Copying the static library to $(DESTDIR)$(OPENBLAS_LIBRARY_DIR)
	@installbsd -c -m 644 $(LIBNAME) "$(DESTDIR)$(OPENBLAS_LIBRARY_DIR)"
	@cd "$(DESTDIR)$(OPENBLAS_LIBRARY_DIR)" ; \
	$(LNCMD) $(LIBNAME) $(LIBPREFIX).$(LIBSUFFIX)
endif
#for install shared library
ifneq ($(NO_SHARED),1)
	@echo Copying the shared library to $(DESTDIR)$(OPENBLAS_LIBRARY_DIR)
	@installbsd -c -m 755 $(LIBSONAME) "$(DESTDIR)$(OPENBLAS_LIBRARY_DIR)"
	@cd "$(DESTDIR)$(OPENBLAS_LIBRARY_DIR)" ; \
	$(LNCMD) $(LIBSONAME) $(LIBPREFIX).so ; \
	$(LNCMD) $(LIBSONAME) $(LIBPREFIX).so.$(MAJOR_VERSION)
endif

endif

#Generating openblas.pc
ifeq ($(INTERFACE64),1)
	SUFFIX64=64
endif
	PKGFILE="$(DESTDIR)$(OPENBLAS_PKGCONFIG_DIR)/$(LIBSONAMEBASE)$(SUFFIX64).pc"

	@echo Generating $(LIBSONAMEBASE)$(SUFFIX64).pc in "$(DESTDIR)$(OPENBLAS_PKGCONFIG_DIR)"
	@echo 'libdir='$(OPENBLAS_LIBRARY_DIR) > "$(PKGFILE)"
	@echo 'libprefix='$(LIBNAMEPREFIX) >> "$(PKGFILE)"
	@echo 'libnamesuffix='$(LIBNAMESUFFIX) >> "$(PKGFILE)"
	@echo 'libsuffix='$(SYMBOLSUFFIX) >> "$(PKGFILE)"
	@echo 'includedir='$(OPENBLAS_INCLUDE_DIR) >> "$(PKGFILE)"
	@echo 'openblas_config= USE_64BITINT='$(INTERFACE64) 'DYNAMIC_ARCH='$(DYNAMIC_ARCH) 'DYNAMIC_OLDER='$(DYNAMIC_OLDER) 'NO_CBLAS='$(NO_CBLAS) 'NO_LAPACK='$(NO_LAPACK) 'NO_LAPACKE='$(NO_LAPACKE) 'NO_AFFINITY='$(NO_AFFINITY) 'USE_OPENMP='$(USE_OPENMP) $(CORE) 'MAX_THREADS='$(NUM_THREADS)>> "$(PKGFILE)"
	@echo 'version='$(VERSION) >> "$(PKGFILE)"
	@echo 'extralib='$(PKG_EXTRALIB) >> "$(PKGFILE)"
	@cat openblas.pc.in >> "$(PKGFILE)"


#Generating OpenBLASConfig.cmake
	@echo Generating $(OPENBLAS_CMAKE_CONFIG) in $(DESTDIR)$(OPENBLAS_CMAKE_DIR)
	@echo "SET(OpenBLAS_VERSION \"${VERSION}\")" > "$(DESTDIR)$(OPENBLAS_CMAKE_DIR)/$(OPENBLAS_CMAKE_CONFIG)"
	@echo "SET(OpenBLAS_INCLUDE_DIRS ${OPENBLAS_INCLUDE_DIR})" >> "$(DESTDIR)$(OPENBLAS_CMAKE_DIR)/$(OPENBLAS_CMAKE_CONFIG)"

ifneq ($(NO_SHARED),1)
#ifeq logical or
ifeq ($(OSNAME), $(filter $(OSNAME),Linux FreeBSD NetBSD OpenBSD DragonFly))
	@echo "SET(OpenBLAS_LIBRARIES ${OPENBLAS_LIBRARY_DIR}/$(LIBPREFIX)$(SYMBOLSUFFIX).so)" >> "$(DESTDIR)$(OPENBLAS_CMAKE_DIR)/$(OPENBLAS_CMAKE_CONFIG)"
endif
ifeq ($(OSNAME), $(filter $(OSNAME),WINNT CYGWIN_NT))
	@echo "SET(OpenBLAS_LIBRARIES ${OPENBLAS_BINARY_DIR}/$(LIBDLLNAME))" >> "$(DESTDIR)$(OPENBLAS_CMAKE_DIR)/$(OPENBLAS_CMAKE_CONFIG)"
endif
ifeq ($(OSNAME), Darwin)
	@echo "SET(OpenBLAS_LIBRARIES ${OPENBLAS_LIBRARY_DIR}/$(LIBPREFIX).dylib)" >> "$(DESTDIR)$(OPENBLAS_CMAKE_DIR)/$(OPENBLAS_CMAKE_CONFIG)"
endif
else
#only static
	@echo "SET(OpenBLAS_LIBRARIES ${OPENBLAS_LIBRARY_DIR}/$(LIBPREFIX).$(LIBSUFFIX))" >> "$(DESTDIR)$(OPENBLAS_CMAKE_DIR)/$(OPENBLAS_CMAKE_CONFIG)"
endif
#Generating OpenBLASConfigVersion.cmake
	@echo Generating $(OPENBLAS_CMAKE_CONFIG_VERSION) in $(DESTDIR)$(OPENBLAS_CMAKE_DIR)
	@echo "set (PACKAGE_VERSION \"${VERSION}\")" > "$(DESTDIR)$(OPENBLAS_CMAKE_DIR)/$(OPENBLAS_CMAKE_CONFIG_VERSION)"
	@echo "if (PACKAGE_VERSION VERSION_LESS PACKAGE_FIND_VERSION)" >> "$(DESTDIR)$(OPENBLAS_CMAKE_DIR)/$(OPENBLAS_CMAKE_CONFIG_VERSION)"
	@echo "  set (PACKAGE_VERSION_COMPATIBLE FALSE)" >> "$(DESTDIR)$(OPENBLAS_CMAKE_DIR)/$(OPENBLAS_CMAKE_CONFIG_VERSION)"
	@echo "else ()" >> "$(DESTDIR)$(OPENBLAS_CMAKE_DIR)/$(OPENBLAS_CMAKE_CONFIG_VERSION)"
	@echo "  set (PACKAGE_VERSION_COMPATIBLE TRUE)" >> "$(DESTDIR)$(OPENBLAS_CMAKE_DIR)/$(OPENBLAS_CMAKE_CONFIG_VERSION)"
	@echo "  if (PACKAGE_FIND_VERSION STREQUAL PACKAGE_VERSION)" >> "$(DESTDIR)$(OPENBLAS_CMAKE_DIR)/$(OPENBLAS_CMAKE_CONFIG_VERSION)"
	@echo "    set (PACKAGE_VERSION_EXACT TRUE)" >> "$(DESTDIR)$(OPENBLAS_CMAKE_DIR)/$(OPENBLAS_CMAKE_CONFIG_VERSION)"
	@echo "  endif ()" >> "$(DESTDIR)$(OPENBLAS_CMAKE_DIR)/$(OPENBLAS_CMAKE_CONFIG_VERSION)"
	@echo "endif ()" >> "$(DESTDIR)$(OPENBLAS_CMAKE_DIR)/$(OPENBLAS_CMAKE_CONFIG_VERSION)"
	@echo Install OK!

```
File: CMakeLists.txt
```
##
## Author: Hank Anderson <hank@statease.com>
##

cmake_minimum_required(VERSION 2.8.5)

project(OpenBLAS C ASM)

set(OpenBLAS_MAJOR_VERSION 0)
set(OpenBLAS_MINOR_VERSION 3)
set(OpenBLAS_PATCH_VERSION 27.dev)

set(OpenBLAS_VERSION "${OpenBLAS_MAJOR_VERSION}.${OpenBLAS_MINOR_VERSION}.${OpenBLAS_PATCH_VERSION}")

# Adhere to GNU filesystem layout conventions
include(GNUInstallDirs)

include(CMakePackageConfigHelpers)

#######
option(BUILD_WITHOUT_LAPACK "Do not build LAPACK and LAPACKE (Only BLAS or CBLAS)" OFF)

option(BUILD_LAPACK_DEPRECATED "When building LAPACK, include also some older, deprecated routines" ON)

option(BUILD_TESTING "Build LAPACK testsuite when building LAPACK" ON)

option(BUILD_BENCHMARKS "Build the collection of BLAS/LAPACK benchmarks" OFF)

option(C_LAPACK "Build LAPACK from C sources instead of the original Fortran" OFF)

option(BUILD_WITHOUT_CBLAS "Do not build the C interface (CBLAS) to the BLAS functions" OFF)

option(DYNAMIC_ARCH "Include support for multiple CPU targets, with automatic selection at runtime (x86/x86_64, aarch64 or ppc only)" OFF)

option(DYNAMIC_OLDER "Include specific support for older x86 cpu models (Penryn,Dunnington,Atom,Nano,Opteron) with DYNAMIC_ARCH" OFF)

option(BUILD_RELAPACK "Build with ReLAPACK (recursive implementation of several LAPACK functions on top of standard LAPACK)" OFF)

option(USE_LOCKING "Use locks even in single-threaded builds to make them callable from multiple threads" OFF)

option(USE_PERL "Use the older PERL scripts for build preparation instead of universal shell scripts" OFF)

option(NO_WARMUP "Do not run a benchmark on each startup just to find the best location for the memory buffer" ON)

option(FIXED_LIBNAME "Use a non-versioned name for the library and no symbolic linking to variant names" OFF)

set(LIBNAMEPREFIX "" CACHE STRING  "Add a prefix to the openblas part of the library name" )
set(LIBNAMESUFFIX "" CACHE STRING  "Add a suffix after the openblas part of the library name" )

if(${CMAKE_SYSTEM_NAME} MATCHES "Linux")
  option(NO_AFFINITY "Disable support for CPU affinity masks to avoid binding processes from e.g. R or numpy/scipy to a single core" ON)
else()
  set(NO_AFFINITY 1)
endif()

option(CPP_THREAD_SAFETY_TEST "Run a massively parallel DGEMM test to confirm thread safety of the library (requires OpenMP and about 1.3GB of RAM)" OFF)

option(CPP_THREAD_SAFETY_GEMV "Run a massively parallel DGEMV test to confirm thread safety of the library (requires OpenMP)" OFF)
option(BUILD_STATIC_LIBS "Build static library" OFF)
if(NOT BUILD_STATIC_LIBS AND NOT BUILD_SHARED_LIBS)
  set(BUILD_STATIC_LIBS ON CACHE BOOL "Build static library" FORCE)
endif()
if((BUILD_STATIC_LIBS AND BUILD_SHARED_LIBS) AND MSVC)
  message(WARNING "Could not enable both BUILD_STATIC_LIBS and BUILD_SHARED_LIBS with MSVC, Disable BUILD_SHARED_LIBS")
  set(BUILD_SHARED_LIBS OFF CACHE BOOL "Build static library" FORCE)
endif()

# Add a prefix or suffix to all exported symbol names in the shared library.
# Avoids conflicts with other BLAS libraries, especially when using
# 64 bit integer interfaces in OpenBLAS.
set(SYMBOLPREFIX "" CACHE STRING  "Add a prefix to all exported symbol names in the shared library to avoid conflicts with other BLAS libraries" )

set(SYMBOLSUFFIX "" CACHE STRING  "Add a suffix to all exported symbol names in the shared library, e.g. _64 for INTERFACE64 builds" )

#######
if(BUILD_WITHOUT_LAPACK)
  set(NO_LAPACK 1)
  set(NO_LAPACKE 1)
endif()

if(BUILD_WITHOUT_CBLAS)
  set(NO_CBLAS 1)
endif()

#######

if(MSVC AND MSVC_STATIC_CRT)
  set(CompilerFlags
        CMAKE_CXX_FLAGS
        CMAKE_CXX_FLAGS_DEBUG
        CMAKE_CXX_FLAGS_RELEASE
        CMAKE_C_FLAGS
        CMAKE_C_FLAGS_DEBUG
        CMAKE_C_FLAGS_RELEASE
        )
  foreach(CompilerFlag ${CompilerFlags})
    string(REPLACE "/MD" "/MT" ${CompilerFlag} "${${CompilerFlag}}")
  endforeach()
endif()

message(WARNING "CMake support is experimental. It does not yet support all build options and may not produce the same Makefiles that OpenBLAS ships with.")

include("${PROJECT_SOURCE_DIR}/cmake/utils.cmake")
include("${PROJECT_SOURCE_DIR}/cmake/system.cmake")

set(OpenBLAS_LIBNAME ${LIBNAMEPREFIX}openblas${LIBNAMESUFFIX}${SUFFIX64_UNDERSCORE})

set(BLASDIRS interface driver/level2 driver/level3 driver/others)

if (NOT DYNAMIC_ARCH)
  list(APPEND BLASDIRS kernel)
endif ()

if (DEFINED SANITY_CHECK)
  list(APPEND BLASDIRS reference)
endif ()

set(SUBDIRS	${BLASDIRS})
if (NOT NO_LAPACK)
  if(BUILD_RELAPACK)
    list(APPEND SUBDIRS relapack/src)
  endif()
  list(APPEND SUBDIRS lapack)
endif ()

if (NOT DEFINED BUILD_BFLOAT16)
 set (BUILD_BFLOAT16 false)
endif ()
# set which float types we want to build for
if (NOT DEFINED BUILD_SINGLE AND NOT DEFINED BUILD_DOUBLE AND NOT DEFINED BUILD_COMPLEX AND NOT DEFINED BUILD_COMPLEX16)
  # if none are defined, build for all
  # set(BUILD_BFLOAT16 true)
  set(BUILD_SINGLE true)
  set(BUILD_DOUBLE true)
  set(BUILD_COMPLEX true)
  set(BUILD_COMPLEX16 true)
endif ()

if (NOT DEFINED BUILD_MATGEN)
  set(BUILD_MATGEN true)
endif()

set(FLOAT_TYPES "")
if (BUILD_SINGLE)
  message(STATUS "Building Single Precision")
  list(APPEND FLOAT_TYPES "SINGLE") # defines nothing
endif ()

if (BUILD_DOUBLE)
  message(STATUS "Building Double Precision")
  list(APPEND FLOAT_TYPES "DOUBLE") # defines DOUBLE
endif ()

if (BUILD_COMPLEX)
  message(STATUS "Building Complex Precision")
  list(APPEND FLOAT_TYPES "COMPLEX") # defines COMPLEX
endif ()

if (BUILD_COMPLEX16)
  message(STATUS "Building Double Complex Precision")
  list(APPEND FLOAT_TYPES "ZCOMPLEX") # defines COMPLEX and DOUBLE
endif ()

if (BUILD_BFLOAT16)
  message(STATUS "Building Half Precision")
  #  list(APPEND FLOAT_TYPES "BFLOAT16") # defines nothing
endif ()

if (NOT DEFINED CORE OR "${CORE}" STREQUAL "UNKNOWN")
  message(FATAL_ERROR "Detecting CPU failed. Please set TARGET explicitly, e.g. make TARGET=your_cpu_target. Please read README for details.")
endif ()

#Set default output directory
set( CMAKE_LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/lib)
set( CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/lib)
if(MSVC)
  set( CMAKE_LIBRARY_OUTPUT_DIRECTORY_DEBUG ${PROJECT_BINARY_DIR}/lib/Debug)
  set( CMAKE_ARCHIVE_OUTPUT_DIRECTORY_RELEASE ${PROJECT_BINARY_DIR}/lib/Release)
endif ()

# get obj vars into format that add_library likes: $<TARGET_OBJS:objlib> (see http://www.cmake.org/cmake/help/v3.0/command/add_library.html)
set(TARGET_OBJS "")
foreach (SUBDIR ${SUBDIRS})
  add_subdirectory(${SUBDIR})
  string(REPLACE "/" "_" subdir_obj ${SUBDIR})
  list(APPEND TARGET_OBJS "$<TARGET_OBJECTS:${subdir_obj}>")
endforeach ()

# netlib:

# Can't just use lapack-netlib's CMake files, since they are set up to search for BLAS, build and install a binary. We just want to build a couple of lib files out of lapack and lapacke.
# Not using add_subdirectory here because lapack-netlib already has its own CMakeLists.txt. Instead include a cmake script with the sources we want.
if (NOT NO_LAPACK)
  include("${PROJECT_SOURCE_DIR}/cmake/lapack.cmake")
  if (NOT NO_LAPACKE)
    include("${PROJECT_SOURCE_DIR}/cmake/lapacke.cmake")
  endif ()
endif ()

# Only generate .def for dll on MSVC and always produce pdb files for debug and release
if(MSVC)
  if (${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION} VERSION_LESS 3.4)
    set(OpenBLAS_DEF_FILE "${PROJECT_BINARY_DIR}/openblas.def")
  endif()
  set(CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE} /Zi")
  set(CMAKE_SHARED_LINKER_FLAGS_RELEASE "${CMAKE_SHARED_LINKER_FLAGS_RELEASE} /DEBUG /OPT:REF /OPT:ICF")
endif()

if (${DYNAMIC_ARCH})
  add_subdirectory(kernel)
  foreach(TARGET_CORE ${DYNAMIC_CORE})
    message("${TARGET_CORE}")
    list(APPEND TARGET_OBJS "$<TARGET_OBJECTS:kernel_${TARGET_CORE}>")
  endforeach()
endif ()

# add objects to the openblas lib
if(NOT NO_LAPACK)
  add_library(LAPACK_OVERRIDES OBJECT ${LA_SOURCES})
  list(APPEND TARGET_OBJS "$<TARGET_OBJECTS:LAPACK_OVERRIDES>")
endif()
if(NOT NO_LAPACKE)
  add_library(LAPACKE OBJECT ${LAPACKE_SOURCES})
  list(APPEND TARGET_OBJS "$<TARGET_OBJECTS:LAPACKE>")
endif()
#if(BUILD_RELAPACK)
#  add_library(RELAPACK OBJECT ${RELA_SOURCES})
#  list(APPEND TARGET_OBJS "$<TARGET_OBJECTS:RELAPACK>")
#endif()
set(OpenBLAS_LIBS "")
if(BUILD_STATIC_LIBS)
  add_library(${OpenBLAS_LIBNAME}_static STATIC ${TARGET_OBJS} ${OpenBLAS_DEF_FILE})
  target_include_directories(${OpenBLAS_LIBNAME}_static INTERFACE $<INSTALL_INTERFACE:include/openblas${SUFFIX64}>)
  list(APPEND OpenBLAS_LIBS ${OpenBLAS_LIBNAME}_static)
endif()
if(BUILD_SHARED_LIBS)
  add_library(${OpenBLAS_LIBNAME}_shared SHARED ${TARGET_OBJS} ${OpenBLAS_DEF_FILE})
  target_include_directories(${OpenBLAS_LIBNAME}_shared INTERFACE $<INSTALL_INTERFACE:include/openblas${SUFFIX64}>)
  list(APPEND OpenBLAS_LIBS ${OpenBLAS_LIBNAME}_shared)
endif()
if(BUILD_STATIC_LIBS)
  add_library(${OpenBLAS_LIBNAME} ALIAS ${OpenBLAS_LIBNAME}_static)
else()
  add_library(${OpenBLAS_LIBNAME} ALIAS ${OpenBLAS_LIBNAME}_shared)
endif()

set_target_properties(${OpenBLAS_LIBS} PROPERTIES OUTPUT_NAME ${OpenBLAS_LIBNAME})

# Android needs to explicitly link against libm
if (${CMAKE_SYSTEM_NAME} MATCHES "AIX|Android|Linux|FreeBSD|OpenBSD|NetBSD|DragonFly|Darwin")
  if(BUILD_STATIC_LIBS)
    target_link_libraries(${OpenBLAS_LIBNAME}_static m)
  endif()
  if(BUILD_SHARED_LIBS)
    target_link_libraries(${OpenBLAS_LIBNAME}_shared m)
  endif()
endif()

# Seems that this hack doesn't required since macOS 11 Big Sur
if (APPLE AND BUILD_SHARED_LIBS AND CMAKE_HOST_SYSTEM_VERSION VERSION_LESS 20)
  set (CMAKE_C_USE_RESPONSE_FILE_FOR_OBJECTS 1)
  if (NOT NOFORTRAN)
  set (CMAKE_Fortran_USE_RESPONSE_FILE_FOR_OBJECTS 1)
  set (CMAKE_Fortran_CREATE_SHARED_LIBRARY
 "sh -c 'cat ${CMAKE_BINARY_DIR}/CMakeFiles/openblas_shared.dir/objects*.rsp | xargs -n 1024 ${CMAKE_AR} -ru libopenblas.a && exit 0' "
 "sh -c '${CMAKE_AR} -rs libopenblas.a ${CMAKE_BINARY_DIR}/driver/others/CMakeFiles/driver_others.dir/xerbla.c.o && exit 0' "
 "sh -c 'echo \"\" | ${CMAKE_Fortran_COMPILER} -o dummy.o -c -x f95-cpp-input - '"
 "sh -c '${CMAKE_Fortran_COMPILER} -fpic -shared -Wl,-all_load -Wl,-force_load,libopenblas.a -Wl,-noall_load dummy.o -o ${CMAKE_LIBRARY_OUTPUT_DIRECTORY}/libopenblas.${OpenBLAS_MAJOR_VERSION}.${OpenBLAS_MINOR_VERSION}.dylib'"
 "sh -c 'ls -l ${CMAKE_BINARY_DIR}/lib'")
  else ()
  set (CMAKE_C_CREATE_SHARED_LIBRARY
   "sh -c 'cat ${CMAKE_BINARY_DIR}/CMakeFiles/openblas_shared.dir/objects*.rsp | xargs -n 1024 ${CMAKE_AR} -ru libopenblas.a && exit 0' "
   "sh -c '${CMAKE_AR} -rs libopenblas.a ${CMAKE_BINARY_DIR}/driver/others/CMakeFiles/driver_others.dir/xerbla.c.o && exit 0' "
   "sh -c '${CMAKE_C_COMPILER} -fpic -shared -Wl,-all_load -Wl,-force_load,libopenblas.a -Wl,-noall_load -o ${CMAKE_LIBRARY_OUTPUT_DIRECTORY}/libopenblas.${OpenBLAS_MAJOR_VERSION}.${OpenBLAS_MINOR_VERSION}.dylib'")
  endif ()
endif()

# Handle MSVC exports
if(MSVC AND BUILD_SHARED_LIBS)
  if (${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION} VERSION_LESS 3.4)
    include("${PROJECT_SOURCE_DIR}/cmake/export.cmake")
  else()
    # Creates verbose .def file (51KB vs 18KB)
    set_target_properties(${OpenBLAS_LIBNAME}_shared PROPERTIES WINDOWS_EXPORT_ALL_SYMBOLS true)
  endif()
endif()

# Set output for libopenblas
set_target_properties( ${OpenBLAS_LIBS} PROPERTIES RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/lib)
set_target_properties( ${OpenBLAS_LIBS} PROPERTIES LIBRARY_OUTPUT_NAME_DEBUG "${OpenBLAS_LIBNAME}_d")
set_target_properties( ${OpenBLAS_LIBS} PROPERTIES EXPORT_NAME "OpenBLAS")

foreach (OUTPUTCONFIG ${CMAKE_CONFIGURATION_TYPES})
  string( TOUPPER ${OUTPUTCONFIG} OUTPUTCONFIG )

  set_target_properties( ${OpenBLAS_LIBS} PROPERTIES RUNTIME_OUTPUT_DIRECTORY_${OUTPUTCONFIG} ${PROJECT_BINARY_DIR}/lib/${OUTPUTCONFIG} )
  set_target_properties( ${OpenBLAS_LIBS} PROPERTIES LIBRARY_OUTPUT_DIRECTORY_${OUTPUTCONFIG} ${PROJECT_BINARY_DIR}/lib/${OUTPUTCONFIG} )
  set_target_properties( ${OpenBLAS_LIBS} PROPERTIES ARCHIVE_OUTPUT_DIRECTORY_${OUTPUTCONFIG} ${PROJECT_BINARY_DIR}/lib/${OUTPUTCONFIG} )
endforeach()

enable_testing()

if (USE_THREAD)
  # Add threading library to linker
  find_package(Threads)
  if (THREADS_HAVE_PTHREAD_ARG)
    set_target_properties(${OpenBLAS_LIBS} PROPERTIES
      COMPILE_OPTIONS "-pthread"
      INTERFACE_COMPILE_OPTIONS "-pthread"
    )
  endif()
  if(BUILD_STATIC_LIBS)
    target_link_libraries(${OpenBLAS_LIBNAME}_static ${CMAKE_THREAD_LIBS_INIT})
  endif()
  if(BUILD_SHARED_LIBS)
    target_link_libraries(${OpenBLAS_LIBNAME}_shared ${CMAKE_THREAD_LIBS_INIT})
  endif()
endif()

#if (MSVC OR NOT NOFORTRAN)
if (NOT NO_CBLAS)
  if (NOT ONLY_CBLAS)
  # Broken without fortran on unix
    add_subdirectory(utest)
endif()
endif()

if (NOT NOFORTRAN)
 if (NOT ONLY_CBLAS)
  # Build test and ctest
  add_subdirectory(test)
 endif()
 if (BUILD_TESTING AND NOT BUILD_WITHOUT_LAPACK)
    add_subdirectory(lapack-netlib/TESTING)
  endif()
endif()
  if(NOT NO_CBLAS)
   if (NOT ONLY_CBLAS)
    add_subdirectory(ctest)
   endif()
  endif()
  if (CPP_THREAD_SAFETY_TEST OR CPP_THREAD_SAFETY_GEMV)
    add_subdirectory(cpp_thread_test)
  endif()

if (NOT FIXED_LIBNAME)
set_target_properties(${OpenBLAS_LIBS} PROPERTIES
  VERSION ${OpenBLAS_MAJOR_VERSION}.${OpenBLAS_MINOR_VERSION}
  SOVERSION ${OpenBLAS_MAJOR_VERSION}
)
endif()
if (BUILD_SHARED_LIBS AND BUILD_RELAPACK)
  if (NOT MSVC)
    target_link_libraries(${OpenBLAS_LIBNAME}_shared "-Wl,-allow-multiple-definition")
  else()
    set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} /FORCE:MULTIPLE")
  endif()
endif()

if (BUILD_SHARED_LIBS AND NOT ${SYMBOLPREFIX}${SYMBOLSUFFIX} STREQUAL "")
  if (NOT DEFINED ARCH)
    set(ARCH_IN "x86_64")
  else()
    set(ARCH_IN ${ARCH})
  endif()

  if (${CORE} STREQUAL "generic")
    set(ARCH_IN "GENERIC")
  endif ()

  if (NOT DEFINED EXPRECISION)
    set(EXPRECISION_IN 0)
  else()
    set(EXPRECISION_IN ${EXPRECISION})
  endif()

  if (NOT DEFINED NO_CBLAS)
    set(NO_CBLAS_IN 0)
  else()
    set(NO_CBLAS_IN ${NO_CBLAS})
  endif()

  if (NOT DEFINED NO_LAPACK)
    set(NO_LAPACK_IN 0)
  else()
    set(NO_LAPACK_IN ${NO_LAPACK})
  endif()

  if (NOT DEFINED NO_LAPACKE)
    set(NO_LAPACKE_IN 0)
  else()
    set(NO_LAPACKE_IN ${NO_LAPACKE})
  endif()

  if (NOT DEFINED NEED2UNDERSCORES)
    set(NEED2UNDERSCORES_IN 0)
  else()
    set(NEED2UNDERSCORES_IN ${NEED2UNDERSCORES})
  endif()

  if (NOT DEFINED ONLY_CBLAS)
    set(ONLY_CBLAS_IN 0)
  else()
    set(ONLY_CBLAS_IN ${ONLY_CBLAS})
  endif()

  if (NOT DEFINED BU)
    set(BU _)
  endif()

  if (NOT ${SYMBOLPREFIX} STREQUAL "")
    message(STATUS "adding prefix ${SYMBOLPREFIX} to names of exported symbols in ${OpenBLAS_LIBNAME}")
  endif()
  if (NOT ${SYMBOLSUFFIX} STREQUAL "")
    message(STATUS "adding suffix ${SYMBOLSUFFIX} to names of exported symbols in ${OpenBLAS_LIBNAME}")
  endif()

  if (${BUILD_LAPACK_DEPRECATED})
	  set (BLD 1)
  else ()
	  set (BLD 0)
  endif()
  if (${BUILD_BFLOAT16})
	  set (BBF16 1)
  else ()
	  set (BBF16 0)
  endif()
  if (${BUILD_SINGLE})
	  set (BS 1)
  else ()
	  set (BS 0)
  endif()
  if (${BUILD_DOUBLE})
	  set (BD 1)
  else ()
	  set (BD 0)
  endif()
  if (${BUILD_COMPLEX})
	  set (BC 1)
  else ()
	  set (BC 0)
  endif()
  if (${BUILD_COMPLEX16})
	  set (BZ 1)
  else ()
	  set (BZ 0)
  endif()
  if (NOT USE_PERL)
  add_custom_command(TARGET ${OpenBLAS_LIBNAME}_shared POST_BUILD
	  COMMAND  ${PROJECT_SOURCE_DIR}/exports/gensymbol "objcopy" "${ARCH}" "${BU}" "${EXPRECISION_IN}" "${NO_CBLAS_IN}" "${NO_LAPACK_IN}" "${NO_LAPACKE_IN}" "${NEED2UNDERSCORES_IN}" "${ONLY_CBLAS_IN}" \"${SYMBOLPREFIX}\" \"${SYMBOLSUFFIX}\" "${BLD}" "${BBF16}" "${BS}" "${BD}" "${BC}" "${BZ}" > ${PROJECT_BINARY_DIR}/objcopy.def
    COMMAND objcopy -v --redefine-syms ${PROJECT_BINARY_DIR}/objcopy.def  ${PROJECT_BINARY_DIR}/lib/lib${OpenBLAS_LIBNAME}.so
    COMMENT "renaming symbols"
    )
  else()
  add_custom_command(TARGET ${OpenBLAS_LIBNAME}_shared POST_BUILD
    COMMAND perl ${PROJECT_SOURCE_DIR}/exports/gensymbol.pl "objcopy" "${ARCH}" "${BU}" "${EXPRECISION_IN}" "${NO_CBLAS_IN}" "${NO_LAPACK_IN}" "${NO_LAPACKE_IN}" "${NEED2UNDERSCORES_IN}" "${ONLY_CBLAS_IN}" \"${SYMBOLPREFIX}\" \"${SYMBOLSUFFIX}\" "${BLD}" "${BBF16}" "${BS}" "${BD}" "${BC}" "${BZ}" > ${PROJECT_BINARY_DIR}/objcopy.def
    COMMAND objcopy -v --redefine-syms ${PROJECT_BINARY_DIR}/objcopy.def  ${PROJECT_BINARY_DIR}/lib/lib${OpenBLAS_LIBNAME}.so
    COMMENT "renaming symbols"
    )
  endif()
endif()

if (BUILD_BENCHMARKS)
	#find_package(OpenMP REQUIRED)
  file(GLOB SOURCES "benchmark/*.c")
  if (NOT USE_OPENMP)
  file(GLOB REMFILE "benchmark/smallscaling.c")
  list(REMOVE_ITEM SOURCES ${REMFILE})
  endif()
  if (BUILD_WITHOUT_LAPACK)
  file(GLOB REMFILE "benchmark/cholesky.c")
  list(REMOVE_ITEM SOURCES ${REMFILE})
  file(GLOB REMFILE "benchmark/geev.c")
  list(REMOVE_ITEM SOURCES ${REMFILE})
  file(GLOB REMFILE "benchmark/gesv.c")
  list(REMOVE_ITEM SOURCES ${REMFILE})
  file(GLOB REMFILE "benchmark/getri.c")
  list(REMOVE_ITEM SOURCES ${REMFILE})
  file(GLOB REMFILE "benchmark/potrf.c")
  list(REMOVE_ITEM SOURCES ${REMFILE})
  file(GLOB REMFILE "benchmark/spmv.c")
  list(REMOVE_ITEM SOURCES ${REMFILE})
  file(GLOB REMFILE "benchmark/symv.c")
  list(REMOVE_ITEM SOURCES ${REMFILE})
  file(GLOB REMFILE "benchmark/linpack.c")
  list(REMOVE_ITEM SOURCES ${REMFILE})
  endif()
  if (NOT USE_GEMM3M)
  file(GLOB REMFILE "benchmark/gemm3m.c")
  list(REMOVE_ITEM SOURCES ${REMFILE})
  endif()
  foreach(source ${SOURCES})
    get_filename_component(name ${source} NAME_WE)
    if ((NOT ${name} STREQUAL "zdot-intel") AND (NOT ${name} STREQUAL "cula_wrapper"))
        set(defines DEFAULT COMPLEX DOUBLE "COMPLEX\;DOUBLE")
      foreach(define ${defines})
        set(target_name "benchmark_${name}")
        if (NOT "${define}" STREQUAL "DEFAULT")
          string(JOIN "_" define_str ${define})
          set(target_name "${target_name}_${define_str}")
        endif()
        if ((NOT ${target_name} STREQUAL "benchmark_imax_COMPLEX") AND (NOT ${target_name} STREQUAL "benchmark_imax_COMPLEX_DOUBLE") AND
            (NOT ${target_name} STREQUAL "benchmark_imin_COMPLEX") AND (NOT ${target_name} STREQUAL "benchmark_imin_COMPLEX_DOUBLE") AND
            (NOT ${target_name} STREQUAL "benchmark_max_COMPLEX") AND (NOT ${target_name} STREQUAL "benchmark_max_COMPLEX_DOUBLE") AND
            (NOT ${target_name} STREQUAL "benchmark_min_COMPLEX") AND (NOT ${target_name} STREQUAL "benchmark_min_COMPLEX_DOUBLE"))
          add_executable(${target_name} ${source})
          target_include_directories(${target_name} PRIVATE ${CMAKE_CURRENT_SOURCE_DIR} ${CMAKE_CURRENT_BINARY_DIR})
	    target_link_libraries(${target_name} ${OpenBLAS_LIBNAME} )
	  #  target_link_libraries(${target_name} ${OpenBLAS_LIBNAME} OpenMP::OpenMP_C)
          if (NOT "${define}" STREQUAL "DEFAULT")
            target_compile_definitions(${target_name} PRIVATE ${define})
          endif()
        endif()
      endforeach()
    endif()
  endforeach()
endif()


# Install project

# Install libraries
if(BUILD_SHARED_LIBS AND BUILD_STATIC_LIBS)
  install(TARGETS ${OpenBLAS_LIBNAME}_shared
    EXPORT "OpenBLAS${SUFFIX64}Targets"
    RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
    ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR} )
  install(TARGETS ${OpenBLAS_LIBNAME}_static
    ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR} )
else()
  install(TARGETS ${OpenBLAS_LIBS}
    EXPORT "OpenBLAS${SUFFIX64}Targets"
    RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
    ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR} )
endif()

# Install headers
set(CMAKE_INSTALL_INCLUDEDIR ${CMAKE_INSTALL_INCLUDEDIR}/openblas${SUFFIX64})
set(CMAKE_INSTALL_FULL_INCLUDEDIR ${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_INCLUDEDIR})

message(STATUS "Generating openblas_config.h in ${CMAKE_INSTALL_INCLUDEDIR}")

set(OPENBLAS_CONFIG_H ${CMAKE_BINARY_DIR}/openblas_config.h)
file(WRITE  ${OPENBLAS_CONFIG_H} "#ifndef OPENBLAS_CONFIG_H\n")
file(APPEND ${OPENBLAS_CONFIG_H} "#define OPENBLAS_CONFIG_H\n")
file(STRINGS ${PROJECT_BINARY_DIR}/config.h __lines)
foreach(line ${__lines})
  string(REPLACE "#define " "" line ${line})
  file(APPEND ${OPENBLAS_CONFIG_H} "#define OPENBLAS_${line}\n")
endforeach()
file(APPEND ${OPENBLAS_CONFIG_H} "#define OPENBLAS_VERSION \"OpenBLAS ${OpenBLAS_VERSION}\"\n")
file(READ   ${CMAKE_CURRENT_SOURCE_DIR}/openblas_config_template.h OPENBLAS_CONFIG_TEMPLATE_H_CONTENTS)
file(APPEND ${OPENBLAS_CONFIG_H} "${OPENBLAS_CONFIG_TEMPLATE_H_CONTENTS}\n")
file(APPEND ${OPENBLAS_CONFIG_H} "#endif /* OPENBLAS_CONFIG_H */\n")
install (FILES ${OPENBLAS_CONFIG_H} DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})

if(NOT NOFORTRAN)
  message(STATUS "Generating f77blas.h in ${CMAKE_INSTALL_INCLUDEDIR}")

  set(F77BLAS_H ${CMAKE_BINARY_DIR}/generated/f77blas.h)
  file(WRITE  ${F77BLAS_H} "#ifndef OPENBLAS_F77BLAS_H\n")
  file(APPEND ${F77BLAS_H} "#define OPENBLAS_F77BLAS_H\n")
  file(APPEND ${F77BLAS_H} "#include \"openblas_config.h\"\n")
  file(READ ${CMAKE_CURRENT_SOURCE_DIR}/common_interface.h COMMON_INTERFACE_H_CONTENTS)
  file(APPEND ${F77BLAS_H} "${COMMON_INTERFACE_H_CONTENTS}\n")
  file(APPEND ${F77BLAS_H} "#endif")
  install (FILES ${F77BLAS_H} DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})
endif()

if(NOT NO_CBLAS)
  message (STATUS "Generating cblas.h in ${CMAKE_INSTALL_INCLUDEDIR}")
  set(CBLAS_H ${CMAKE_BINARY_DIR}/generated/cblas.h)
  file(READ ${CMAKE_CURRENT_SOURCE_DIR}/cblas.h CBLAS_H_CONTENTS)
  string(REPLACE "common" "openblas_config" CBLAS_H_CONTENTS_NEW "${CBLAS_H_CONTENTS}")
  if (NOT ${SYMBOLPREFIX} STREQUAL "")
    string(REPLACE " cblas" " ${SYMBOLPREFIX}cblas" CBLAS_H_CONTENTS	"${CBLAS_H_CONTENTS_NEW}")
    string(REPLACE " openblas" " ${SYMBOLPREFIX}openblas" CBLAS_H_CONTENTS_NEW	"${CBLAS_H_CONTENTS}")
    string (REPLACE " ${SYMBOLPREFIX}openblas_complex" " openblas_complex" CBLAS_H_CONTENTS	"${CBLAS_H_CONTENTS_NEW}")
    string(REPLACE " goto" " ${SYMBOLPREFIX}goto" CBLAS_H_CONTENTS_NEW "${CBLAS_H_CONTENTS}")
  endif()
  if (NOT ${SYMBOLSUFFIX} STREQUAL "")
    string(REGEX REPLACE "(cblas[^ (]*)" "\\1${SYMBOLSUFFIX}" CBLAS_H_CONTENTS	"${CBLAS_H_CONTENTS_NEW}")
    string(REGEX REPLACE "(openblas[^ (]*)" "\\1${SYMBOLSUFFIX}" CBLAS_H_CONTENTS_NEW "${CBLAS_H_CONTENTS}")
    string(REGEX REPLACE "(openblas_complex[^ ]*)${SYMBOLSUFFIX}" "\\1" CBLAS_H_CONTENTS	"${CBLAS_H_CONTENTS_NEW}")
    string(REGEX REPLACE "(goto[^ (]*)" "\\1${SYMBOLSUFFIX}" CBLAS_H_CONTENTS_NEW	"${CBLAS_H_CONTENTS}")
  endif()
  file(WRITE ${CBLAS_H} "${CBLAS_H_CONTENTS_NEW}")
  install (FILES ${CBLAS_H} DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})
endif()

if(NOT NO_LAPACKE)
  message (STATUS "Copying LAPACKE header files to ${CMAKE_INSTALL_INCLUDEDIR}")
  if(BUILD_STATIC_LIBS)
    add_dependencies( ${OpenBLAS_LIBNAME}_static genlapacke)
  endif()
  if(BUILD_SHARED_LIBS)
    add_dependencies( ${OpenBLAS_LIBNAME}_shared genlapacke)
  endif()
  FILE(GLOB_RECURSE INCLUDE_FILES "${CMAKE_CURRENT_SOURCE_DIR}/lapack-netlib/LAPACKE/*.h")
  install (FILES ${INCLUDE_FILES} DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})

  ADD_CUSTOM_TARGET(genlapacke
  COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_SOURCE_DIR}/lapack-netlib/LAPACKE/include/lapacke_mangling_with_flags.h.in "${CMAKE_BINARY_DIR}/lapacke_mangling.h"
  )
  install (FILES ${CMAKE_BINARY_DIR}/lapacke_mangling.h DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})
endif()

# Install pkg-config files
configure_file(${PROJECT_SOURCE_DIR}/cmake/openblas.pc.in ${PROJECT_BINARY_DIR}/openblas${SUFFIX64}.pc @ONLY)
install (FILES ${PROJECT_BINARY_DIR}/openblas${SUFFIX64}.pc DESTINATION ${CMAKE_INSTALL_LIBDIR}/pkgconfig/)


set(PN OpenBLAS)
set(CMAKECONFIG_INSTALL_DIR "${CMAKE_INSTALL_LIBDIR}/cmake/${PN}${SUFFIX64}")
configure_package_config_file(cmake/${PN}Config.cmake.in
                              "${CMAKE_CURRENT_BINARY_DIR}/${PN}${SUFFIX64}Config.cmake"
                              INSTALL_DESTINATION ${CMAKECONFIG_INSTALL_DIR})
write_basic_package_version_file(${CMAKE_CURRENT_BINARY_DIR}/${PN}ConfigVersion.cmake
                                 VERSION ${${PN}_VERSION}
                                 COMPATIBILITY AnyNewerVersion)
install(FILES ${CMAKE_CURRENT_BINARY_DIR}/${PN}${SUFFIX64}Config.cmake
        DESTINATION ${CMAKECONFIG_INSTALL_DIR})
install(FILES ${CMAKE_CURRENT_BINARY_DIR}/${PN}ConfigVersion.cmake
        RENAME ${PN}${SUFFIX64}ConfigVersion.cmake
        DESTINATION ${CMAKECONFIG_INSTALL_DIR})
install(EXPORT "${PN}${SUFFIX64}Targets"
        NAMESPACE "${PN}${SUFFIX64}::"
        DESTINATION ${CMAKECONFIG_INSTALL_DIR})

```
File: quickbuild.win64
```
#!/bin/bash

echo " Please read https://github.com/xianyi/OpenBLAS/wiki/How-to-use-OpenBLAS-in-Microsoft-Visual-Studio "
make BINARY=64 CC=gcc FC=gfortran

```
File: .travis.yml
```
# XXX: Precise is already deprecated, new default is Trusty.
# https://blog.travis-ci.com/2017-07-11-trusty-as-default-linux-is-coming
dist: focal
sudo: true
language: c

matrix:
  include:
    - &test-ubuntu
#      os: linux
      compiler: gcc
      addons:
        apt:
          packages:
            - gfortran
#      before_script: &common-before
#        - COMMON_FLAGS="DYNAMIC_ARCH=1 TARGET=NEHALEM NUM_THREADS=32"
#      script:
#        - make QUIET_MAKE=1 $COMMON_FLAGS $BTYPE
#        - make -C test $COMMON_FLAGS $BTYPE
#        - make -C ctest $COMMON_FLAGS $BTYPE
#        - make -C utest $COMMON_FLAGS $BTYPE
#      env:
#        - TARGET_BOX=LINUX64
#        - BTYPE="BINARY=64"
#
#    - <<: *test-ubuntu
      os: linux
      arch: ppc64le
      before_script: &common-before
        - COMMON_FLAGS="DYNAMIC_ARCH=1 TARGET=POWER8 NUM_THREADS=32"
      script:
        - travis_wait 50 make QUIET_MAKE=1 $COMMON_FLAGS $BTYPE
        - make -C test $COMMON_FLAGS $BTYPE
        - make -C ctest $COMMON_FLAGS $BTYPE
        - make -C utest $COMMON_FLAGS $BTYPE
      env:
        # for matrix annotation only
        - TARGET_BOX=PPC64LE_LINUX
        - BTYPE="BINARY=64 USE_OPENMP=1"

    - <<: *test-ubuntu
      os: linux
      arch: s390x
      before_script:
        - COMMON_FLAGS="DYNAMIC_ARCH=1 TARGET=Z13 NUM_THREADS=32"
        - sudo apt-get install --only-upgrade binutils
      env:
        # for matrix annotation only
        - TARGET_BOX=IBMZ_LINUX
        - BTYPE="BINARY=64 USE_OPENMP=1"

    - <<: *test-ubuntu
      os: linux
      dist: focal
      arch: s390x
      compiler: clang
      before_script:
        - COMMON_FLAGS="DYNAMIC_ARCH=1 TARGET=Z13 NUM_THREADS=32"
        - sudo apt-get install --only-upgrade binutils
      env:
        # for matrix annotation only
        - TARGET_BOX=IBMZ_LINUX
        - BTYPE="BINARY=64 USE_OPENMP=0 CC=clang"

#    - <<: *test-ubuntu
#      env:
#        - TARGET_BOX=LINUX64
#        - BTYPE="BINARY=64 USE_OPENMP=1"
#
#    - <<: *test-ubuntu
#      env:
#        - TARGET_BOX=LINUX64
#        - BTYPE="BINARY=64 INTERFACE64=1"
#
#    - <<: *test-ubuntu
#      compiler: clang
#      env:
#        - TARGET_BOX=LINUX64
#        - BTYPE="BINARY=64 CC=clang"
#
#    - <<: *test-ubuntu
#      compiler: clang
#      env:
#        - TARGET_BOX=LINUX64
#        - BTYPE="BINARY=64 INTERFACE64=1 CC=clang"
#
#    - <<: *test-ubuntu
#      addons:
#        apt:
#          packages:
#            - gcc-multilib
#            - gfortran-multilib
#      env:
#        - TARGET_BOX=LINUX32
#        - BTYPE="BINARY=32"
#
    - os: linux
      arch: ppc64le
      dist: bionic
      compiler: gcc
      before_script:
        - sudo add-apt-repository 'ppa:ubuntu-toolchain-r/test' -y
        - sudo apt-get update
        - sudo apt-get install gcc-9 gfortran-9 -y
      script:
        - travis_wait 50 make QUIET_MAKE=1  BINARY=64 USE_OPENMP=1 CC=gcc-9 FC=gfortran-9
        - make -C test $COMMON_FLAGS $BTYPE
        - make -C ctest $COMMON_FLAGS $BTYPE
        - make -C utest $COMMON_FLAGS $BTYPE 
      env:
        # for matrix annotation only
        - TARGET_BOX=PPC64LE_LINUX_P9

    - os: linux
      arch: ppc64le
      dist: bionic
      compiler: gcc
      before_script:
        - sudo add-apt-repository 'ppa:ubuntu-toolchain-r/test' -y
        - sudo apt-get update
        - sudo apt-get install gcc-9 gfortran-9 -y
      script:
        - travis_wait 50 make QUIET_MAKE=1  BUILD_BFLOAT16=1 BINARY=64 USE_OPENMP=1 CC=gcc-9 FC=gfortran-9
        - make -C test $COMMON_FLAGS $BTYPE
        - make -C ctest $COMMON_FLAGS $BTYPE
        - make -C utest $COMMON_FLAGS $BTYPE 
      env:
        # for matrix annotation only
        - TARGET_BOX=PPC64LE_LINUX_P9

#    - os: linux
#      compiler: gcc
#      addons:
#        apt:
#          packages:
#            - binutils-mingw-w64-x86-64
#            - gcc-mingw-w64-x86-64
#            - gfortran-mingw-w64-x86-64
#      before_script: *common-before
#      script:
#        - travis_wait 45 make QUIET_MAKE=1 $COMMON_FLAGS $BTYPE
#      env:
#        - TARGET_BOX=WIN64
#        - BTYPE="BINARY=64 HOSTCC=gcc CC=x86_64-w64-mingw32-gcc FC=x86_64-w64-mingw32-gfortran"
#
    # Build & test on Alpine Linux inside chroot, i.e. on system with musl libc.
    # These jobs needs sudo, so Travis runs them on VM-based infrastructure
    # which is slower than container-based infrastructure used for jobs
    # that don't require sudo.
 #   - &test-alpine
 #     os: linux
 #     dist: trusty
 #     sudo: true
 #     language: minimal
 #     before_install:
 #       - "wget 'https://raw.githubusercontent.com/alpinelinux/alpine-chroot-install/v0.9.0/alpine-chroot-install' \
 #         && echo 'e5dfbbdc0c4b3363b99334510976c86bfa6cb251  alpine-chroot-install' | sha1sum -c || exit 1"
 #       - alpine() { /alpine/enter-chroot -u "$USER" "$@"; }
 #     install:
 #       - sudo sh alpine-chroot-install -p 'build-base gfortran perl linux-headers'
 #     before_script: *common-before
 #     script:
 #       # XXX: Disable some warnings for now to avoid exceeding Travis limit for log size.
 #       - alpine make QUIET_MAKE=1 $COMMON_FLAGS $BTYPE
 #             CFLAGS="-Wno-misleading-indentation -Wno-sign-conversion -Wno-incompatible-pointer-types"
 #       - alpine make -C test $COMMON_FLAGS $BTYPE
 #       - alpine make -C ctest $COMMON_FLAGS $BTYPE
 #       - alpine make -C utest $COMMON_FLAGS $BTYPE
 #     env:
 #       - TARGET_BOX=LINUX64_MUSL
 #       - BTYPE="BINARY=64"

    # XXX: This job segfaults in TESTS OF THE COMPLEX LEVEL 3 BLAS,
    # but only on Travis CI, cannot reproduce it elsewhere.
    #- &test-alpine-openmp
    #  <<: *test-alpine
    #  env:
    #    - TARGET_BOX=LINUX64_MUSL
    #    - BTYPE="BINARY=64 USE_OPENMP=1"

#    - <<: *test-alpine
#      env:
#        - TARGET_BOX=LINUX64_MUSL
#        - BTYPE="BINARY=64 INTERFACE64=1"
#
#    # Build with the same flags as Alpine do in OpenBLAS package.
#    - <<: *test-alpine
#      env:
#        - TARGET_BOX=LINUX64_MUSL
#        - BTYPE="BINARY=64 NO_AFFINITY=1 USE_OPENMP=0 NO_LAPACK=0 TARGET=CORE2"

#    - &test-cmake
#      os: linux
#      compiler: clang
#      addons:
#        apt:
#          packages:
#            - gfortran
#            - cmake
#      dist: trusty
#      sudo: true
#      before_script:
#        - COMMON_ARGS="-DTARGET=NEHALEM -DNUM_THREADS=32"
#      script:
#        - mkdir build
#        - CONFIG=Release
#        - cmake -Bbuild -H. $CMAKE_ARGS $COMMON_ARGS -DCMAKE_BUILD_TYPE=$CONFIG
#        - cmake --build build --config $CONFIG -- -j2
#      env:
#        - CMAKE=1
#    - <<: *test-cmake
#      env:
#        - CMAKE=1 CMAKE_ARGS="-DNOFORTRAN=1"
#    - <<: *test-cmake
#      compiler: gcc
#      env:
#        - CMAKE=1

#    - &test-macos
#      os: osx
#      osx_image: xcode11.5
#      before_script:
#        - COMMON_FLAGS="DYNAMIC_ARCH=1 NUM_THREADS=32"
#      script:
#        - travis_wait 45 make QUIET_MAKE=1 $COMMON_FLAGS $BTYPE
#      env:
#        - BTYPE="TARGET=NEHALEM BINARY=64 INTERFACE64=1 FC=gfortran-9"
#
#    - <<: *test-macos
#      osx_image: xcode12
#      before_script:
#        - COMMON_FLAGS="DYNAMIC_ARCH=1 NUM_THREADS=32"
#        - brew update
#      script:
#        - travis_wait 45 make QUIET_MAKE=1 $COMMON_FLAGS $BTYPE
#      env:
#        - BTYPE="TARGET=HASWELL USE_OPENMP=1 BINARY=64 INTERFACE64=1 CC=gcc-10 FC=gfortran-10"
#
#    - <<: *test-macos
#      osx_image: xcode12
#      before_script:
#        - COMMON_FLAGS="DYNAMIC_ARCH=1 NUM_THREADS=32"
#        - brew update
#      script:
#        - travis_wait 45 make QUIET_MAKE=1 $COMMON_FLAGS $BTYPE
#      env:
#        - BTYPE="TARGET=NEHALEM BINARY=64 INTERFACE64=1 FC=gfortran-10"      

  #  - <<: *test-macos
  #    osx_image: xcode10
  #    env:
  #      - BTYPE="TARGET=NEHALEM BINARY=32 NOFORTRAN=1"

#    - <<: *test-macos
#      osx_image: xcode11.5
#      before_script:
#        - COMMON_FLAGS="DYNAMIC_ARCH=1 NUM_THREADS=32"
#        - brew update
#      env:
#        - CC="/Applications/Xcode-10.1.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang"
#        - CFLAGS="-O2 -Wno-macro-redefined -isysroot /Applications/Xcode-10.1.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS12.1.sdk -arch arm64 -miphoneos-version-min=10.0"
#        - CC="/Applications/Xcode-11.5.GM.Seed.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang"
#        - CFLAGS="-O2 -Wno-macro-redefined -isysroot /Applications/Xcode-11.5.GM.Seed.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk -arch arm64 -miphoneos-version-min=10.0"
#        - BTYPE="TARGET=ARMV8 BINARY=64 HOSTCC=clang NOFORTRAN=1"
#    - <<: *test-macos
#      osx_image: xcode11.5
#      env:
##        - CC="/Applications/Xcode-10.1.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang"
##        - CFLAGS="-O2 -mno-thumb -Wno-macro-redefined -isysroot /Applications/Xcode-10.1.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS12.1.sdk -arch armv7 -miphoneos-version-min=5.1"
#        - CC="/Applications/Xcode-11.5.GM.Seed.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang"
#        - CFLAGS="-O2 -mno-thumb -Wno-macro-redefined -isysroot /Applications/Xcode-11.5.GM.Seed.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk -arch armv7 -miphoneos-version-min=5.1"
#        - BTYPE="TARGET=ARMV7 HOSTCC=clang NOFORTRAN=1"

    - &test-neoversen1
      os: linux
      arch: arm64
      dist: focal
      group: edge
      virt: lxd
      compiler: gcc
      addons:
        apt:
          packages:
            - gfortran
      script:
        - travis_wait 45 make && make lapack-test
      env:
        - TARGET_BOX=NEOVERSE_N1 
  
    - &test-neon1-gcc8
      os: linux
      arch: arm64
      dist: focal
      group: edge
      virt: lxd
      compiler: gcc
      addons:
        apt:
          packages:
            - gcc-8
            - gfortran-8
      script:
        - travis_wait 45 make QUIET_MAKE=1 CC=gcc-8 FC=gfortran-8 DYNAMIC_ARCH=1 
      env:
        - TARGET_BOX=NEOVERSE_N1-GCC8
        
# whitelist
branches:
  only:
    - master
    - develop

notifications:
  webhooks:
    urls:
      - https://webhooks.gitter.im/e/8a6e4470a0cebd090344
    on_success: change  # options: [always|never|change] default: always
    on_failure: always  # options: [always|never|change] default: always
    on_start: never     # options: [always|never|change] default: always

```
File: .drone.yml
```
---
kind: pipeline
name: arm64_gcc_make

platform:
  os: linux
  arch: arm64

steps:
- name: Build and Test
  image: ubuntu:18.04
  environment:
    CC: gcc
    COMMON_FLAGS: 'DYNAMIC_ARCH=1 TARGET=ARMV8 NUM_THREADS=32'
  commands:
    - echo "MAKE_FLAGS:= $COMMON_FLAGS"
    - apt-get update -y
    - apt-get install -y make $CC gfortran perl
    - $CC --version
    - make QUIET_MAKE=1 $COMMON_FLAGS
    - make -C test $COMMON_FLAGS
    - make -C ctest $COMMON_FLAGS
    - make -C utest $COMMON_FLAGS

---
kind: pipeline
name: arm32_gcc_make

platform:
  os: linux
  arch: arm

steps:
- name: Build and Test
  image: ubuntu:18.04
  environment:
    CC: gcc
    COMMON_FLAGS: 'DYNAMIC_ARCH=1 TARGET=ARMV6 NUM_THREADS=32'
  commands:
    - echo "MAKE_FLAGS:= $COMMON_FLAGS"
    - apt-get update -y
    - apt-get install -y make $CC gfortran perl
    - $CC --version
    - make QUIET_MAKE=1 $COMMON_FLAGS
    - make -C test $COMMON_FLAGS
    - make -C ctest $COMMON_FLAGS
    - make -C utest $COMMON_FLAGS

---
kind: pipeline
name: arm64_clang_make

platform:
  os: linux
  arch: arm64

steps:
- name: Build and Test
  image: ubuntu:18.04
  environment:
    CC: clang
    COMMON_FLAGS: 'DYNAMIC_ARCH=1 TARGET=ARMV8 NUM_THREADS=32'
  commands:
    - echo "MAKE_FLAGS:= $COMMON_FLAGS"
    - apt-get update -y
    - apt-get install -y make $CC gfortran perl
    - $CC --version
    - make QUIET_MAKE=1 $COMMON_FLAGS
    - make -C test $COMMON_FLAGS
    - make -C ctest $COMMON_FLAGS
    - make -C utest $COMMON_FLAGS

---
kind: pipeline
name: arm32_clang_cmake

platform:
  os: linux
  arch: arm

steps:
- name: Build and Test
  image: ubuntu:18.04
  environment:
    CC: clang
    CMAKE_FLAGS: '-DDYNAMIC_ARCH=1 -DTARGET=ARMV6 -DNUM_THREADS=32 -DNOFORTRAN=ON -DBUILD_WITHOUT_LAPACK=ON'
  commands:
    - echo "CMAKE_FLAGS:= $CMAKE_FLAGS"
    - apt-get update -y
    - apt-get install -y make $CC g++ perl cmake
    - $CC --version
    - mkdir build && cd build
    - cmake $CMAKE_FLAGS ..
    - make -j
    - ctest -V

---
kind: pipeline
name: arm64_gcc_cmake

platform:
  os: linux
  arch: arm64

steps:
- name: Build and Test
  image: ubuntu:18.04
  environment:
    CC: gcc
    CMAKE_FLAGS: '-DDYNAMIC_ARCH=1 -DTARGET=ARMV8 -DNUM_THREADS=32 -DNOFORTRAN=ON -DBUILD_WITHOUT_LAPACK=ON'
  commands:
    - echo "CMAKE_FLAGS:= $CMAKE_FLAGS"
    - apt-get update -y
    - apt-get install -y make $CC g++ perl cmake
    - $CC --version
    - mkdir build && cd build
    - cmake $CMAKE_FLAGS ..
    - make -j
    - ctest -V

---
kind: pipeline
name: arm64_clang_cmake

platform:
  os: linux
  arch: arm64

steps:
- name: Build and Test
  image: ubuntu:18.04
  environment:
    CC: clang
    CMAKE_FLAGS: '-DDYNAMIC_ARCH=1 -DTARGET=ARMV8 -DNUM_THREADS=32 -DNOFORTRAN=ON -DBUILD_WITHOUT_LAPACK=ON'
  commands:
    - echo "CMAKE_FLAGS:= $CMAKE_FLAGS"
    - apt-get update -y
    - apt-get install -y make $CC g++ perl cmake
    - $CC --version
    - mkdir build && cd build
    - cmake $CMAKE_FLAGS ..
    - make -j
    - ctest -V

---
kind: pipeline
name: arm64_native_test

platform:
  os: linux
  arch: arm64

steps:
- name: Build and Test
  image: ubuntu:18.04
  environment:
    CC: gcc
    COMMON_FLAGS: 'USE_OPENMP=1'
  commands:
    - echo "MAKE_FLAGS:= $COMMON_FLAGS"
    - apt-get update -y
    - apt-get install -y make $CC gfortran perl python g++
    - $CC --version
    - make QUIET_MAKE=1 $COMMON_FLAGS
    - make -C test $COMMON_FLAGS
    - make -C ctest $COMMON_FLAGS
    - make -C utest $COMMON_FLAGS
    - make -C cpp_thread_test dgemm_tester
---
kind: pipeline
name: epyc_native_test

platform:
  os: linux
  arch: amd64

steps:
- name: Build and Test
  image: ubuntu:18.04
  environment:
    CC: gcc
    COMMON_FLAGS: 'USE_OPENMP=1'
  commands:
    - echo "MAKE_FLAGS:= $COMMON_FLAGS"
    - apt-get update -y
    - apt-get install -y make $CC gfortran perl python g++
    - $CC --version
    - make QUIET_MAKE=1 $COMMON_FLAGS
    - make -C test $COMMON_FLAGS
    - make -C ctest $COMMON_FLAGS
    - make -C utest $COMMON_FLAGS
    - make -C cpp_thread_test dgemm_tester
---
kind: pipeline
name: arm64_gcc10

platform:
  os: linux
  arch: arm64

steps:
- name: Build and Test
  image: ubuntu:20.04
  environment:
    CC: gcc-10
    FC: gfortran-10
    COMMON_FLAGS: 'TARGET=ARMV8 DYNAMIC_ARCH=1'
  commands:
    - echo "MAKE_FLAGS:= $COMMON_FLAGS"
    - apt-get update -y
    - apt-get install -y make $CC gfortran-10 perl python g++
    - $CC --version
    - make QUIET_MAKE=1 $COMMON_FLAGS
    - make -C utest $COMMON_FLAGS
    - make -C test $COMMON_FLAGS
    

```
File: appveyor.yml
```
version: 0.2.19.{build}

#environment:

platform: 
  - x64

os: Visual Studio 2017

configuration: Release

clone_folder: c:\projects\OpenBLAS

init:
  - git config --global core.autocrlf input

clone_depth: 5

skip_tags: true

matrix:
  fast_finish: false

skip_commits:
# Add [av skip] to commit messages
  message: /\[av skip\]/

environment:
  global:
    CONDA_INSTALL_LOCN: C:\\Miniconda36-x64
  matrix:
#    - COMPILER: clang-cl
#      WITH_FORTRAN: ON
#    - COMPILER: clang-cl
#      DYNAMIC_ARCH: ON
#      WITH_FORTRAN: OFF
#    - COMPILER: cl
#    - COMPILER: MinGW64-gcc-7.2.0-mingw
#      DYNAMIC_ARCH: OFF
#      WITH_FORTRAN: ignore
    - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2015
      COMPILER: MinGW-gcc-6.3.0-32   
    - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2015
      COMPILER: MinGW-gcc-5.3.0
      WITH_FORTRAN: ignore
    
install:
  - if [%COMPILER%]==[clang-cl] call %CONDA_INSTALL_LOCN%\Scripts\activate.bat
  - if [%COMPILER%]==[clang-cl] conda update --yes -n base conda
  - if [%COMPILER%]==[clang-cl] conda config --add channels conda-forge --force
  - if [%COMPILER%]==[clang-cl] conda config --set auto_update_conda false
  - if [%COMPILER%]==[clang-cl] conda install --yes --quiet clangdev cmake ninja flang=11.0.1
  - if [%COMPILER%]==[clang-cl] call "C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Auxiliary\Build\vcvarsall.bat" x64
  - if [%COMPILER%]==[clang-cl] set "LIB=%CONDA_INSTALL_LOCN%\Library\lib;%LIB%"
  - if [%COMPILER%]==[clang-cl] set "CPATH=%CONDA_INSTALL_LOCN%\Library\include;%CPATH%"

before_build:
  - ps: if (-Not (Test-Path .\build)) { mkdir build }
  - cd build
  - set PATH=%PATH:C:\Program Files\Git\usr\bin;=%
  - if [%COMPILER%]==[MinGW-gcc-5.3.0] set PATH=C:\MinGW\bin;C:\msys64\usr\bin;C:\mingw-w64\x86_64-7.2.0-posix-seh-rt_v5-rev1\mingw64\bin;%PATH%
  - if [%COMPILER%]==[MinGW64-gcc-7.2.0-mingw] set PATH=C:\MinGW\bin;C:\mingw-w64\x86_64-7.2.0-posix-seh-rt_v5-rev1\mingw64\bin;%PATH%
  - if [%COMPILER%]==[MinGW-gcc-6.3.0-32] set PATH=C:\msys64\usr\bin;C:\mingw-w64\i686-6.3.0-posix-dwarf-rt_v5-rev1\mingw64\bin;%PATH%
  - if [%COMPILER%]==[cl] cmake -G "Visual Studio 15 2017 Win64" ..
  - if [%COMPILER%]==[MinGW64-gcc-7.2.0-mingw] cmake -G "MinGW Makefiles" -DNOFORTRAN=1 ..
  - if [%COMPILER%]==[MinGW-gcc-6.3.0-32] cmake -G "MSYS Makefiles" -DNOFORTRAN=1 ..
  - if [%COMPILER%]==[MinGW-gcc-5.3.0] cmake -G "MSYS Makefiles" -DNOFORTRAN=1 ..
  - if [%WITH_FORTRAN%]==[OFF] cmake -G "Ninja" -DCMAKE_CXX_COMPILER=clang-cl -DCMAKE_C_COMPILER=clang-cl -DCMAKE_MT=mt -DMSVC_STATIC_CRT=ON ..
  - if [%WITH_FORTRAN%]==[ON] cmake -G "Ninja" -DCMAKE_CXX_COMPILER=clang-cl -DCMAKE_C_COMPILER=clang-cl -DCMAKE_Fortran_COMPILER=flang -DCMAKE_MT=mt -DBUILD_WITHOUT_LAPACK=no -DNOFORTRAN=0 ..
  - if [%USE_OPENMP%]==[ON] cmake -DUSE_OPENMP=ON ..
  - if [%DYNAMIC_ARCH%]==[ON] cmake -DDYNAMIC_ARCH=ON -DDYNAMIC_LIST='CORE2;NEHALEM;SANDYBRIDGE;BULLDOZER;HASWELL' ..

build_script:
  - cmake --build .

test_script:
  - ctest -j2
  

```
File: USAGE.md
```
# Notes on OpenBLAS usage
## Usage

#### Program is Terminated. Because you tried to allocate too many memory regions

In OpenBLAS, we mange a pool of memory buffers and allocate the number of
buffers as the following.
```
#define NUM_BUFFERS (MAX_CPU_NUMBER * 2)
```
This error indicates that the program exceeded the number of buffers.

Please build OpenBLAS with larger `NUM_THREADS`. For example, `make
NUM_THREADS=32` or `make NUM_THREADS=64`.  In `Makefile.system`, we will set
`MAX_CPU_NUMBER=NUM_THREADS`.

Despite its name, and due to the use of memory buffers in functions like SGEMM,
the setting of NUM_THREADS can be relevant even for a single-threaded build 
of OpenBLAS, if such functions get called by multiple threads of a program
that uses OpenBLAS. In some cases, the affected code may simply crash or throw 
a segmentation fault without displaying the above warning first.

Note that the number of threads used at runtime can be altered to differ from the
value NUM_THREADS was set to at build time. At runtime, the actual number of
threads can be set anywhere from 1 to the build's NUM_THREADS (note however,
that this does not change the number of memory buffers that will be allocated,
which is set at build time). The number of threads for a process can be set by
using the mechanisms described below.


#### How can I use OpenBLAS in multi-threaded applications?

If your application is already multi-threaded, it will conflict with OpenBLAS
multi-threading. Thus, you must set OpenBLAS to use single thread in any of the
following ways:

* `export OPENBLAS_NUM_THREADS=1` in the environment variables.
* Call `openblas_set_num_threads(1)` in the application on runtime.
* Build OpenBLAS single thread version, e.g. `make USE_THREAD=0`

If the application is parallelized by OpenMP, please use OpenBLAS built with
`USE_OPENMP=1`

#### How to choose TARGET manually at runtime when compiled with DYNAMIC_ARCH

The environment variable which control the kernel selection is
`OPENBLAS_CORETYPE` (see `driver/others/dynamic.c`) e.g. `export
OPENBLAS_CORETYPE=Haswell` and the function `char* openblas_get_corename()`
returns the used target.

#### How could I disable OpenBLAS threading affinity on runtime?

You can define the `OPENBLAS_MAIN_FREE` or `GOTOBLAS_MAIN_FREE` environment
variable to disable threading affinity on runtime. For example, before the
running,
```
export OPENBLAS_MAIN_FREE=1
```

Alternatively, you can disable affinity feature with enabling `NO_AFFINITY=1`
in `Makefile.rule`.

## Linking with the library

* Link with shared library

`gcc -o test test.c -I /your_path/OpenBLAS/include/ -L/your_path/OpenBLAS/lib -lopenblas`

If the library is multithreaded, please add `-lpthread`. If the library
contains LAPACK functions, please add `-lgfortran` or other Fortran libs.

* Link with static library

`gcc -o test test.c /your/path/libopenblas.a`

You can download `test.c` from https://gist.github.com/xianyi/5780018

On Linux, if OpenBLAS was compiled with threading support (`USE_THREAD=1` by
default), custom programs statically linked against `libopenblas.a` should also
link with the pthread library e.g.:

```
gcc -static -I/opt/OpenBLAS/include -L/opt/OpenBLAS/lib -o my_program my_program.c -lopenblas -lpthread
```

Failing to add the `-lpthread` flag will cause errors such as:

```
/opt/OpenBLAS/libopenblas.a(memory.o): In function `_touch_memory':
memory.c:(.text+0x15): undefined reference to `pthread_mutex_lock'
memory.c:(.text+0x41): undefined reference to `pthread_mutex_unlock'
...
```

## Code examples

#### Call CBLAS interface
This example shows calling cblas_dgemm in C. https://gist.github.com/xianyi/6930656
```
#include <cblas.h>
#include <stdio.h>

void main()
{
  int i=0;
  double A[6] = {1.0,2.0,1.0,-3.0,4.0,-1.0};
  double B[6] = {1.0,2.0,1.0,-3.0,4.0,-1.0};
  double C[9] = {.5,.5,.5,.5,.5,.5,.5,.5,.5};
  cblas_dgemm(CblasColMajor, CblasNoTrans, CblasTrans,3,3,2,1,A, 3, B, 3,2,C,3);

  for(i=0; i<9; i++)
    printf("%lf ", C[i]);
  printf("\n");
}
```
`gcc -o test_cblas_open test_cblas_dgemm.c -I /your_path/OpenBLAS/include/ -L/your_path/OpenBLAS/lib -lopenblas -lpthread -lgfortran`

#### Call BLAS Fortran interface

This example shows calling dgemm Fortran interface in C. https://gist.github.com/xianyi/5780018

```
#include "stdio.h"
#include "stdlib.h"
#include "sys/time.h"
#include "time.h"

extern void dgemm_(char*, char*, int*, int*,int*, double*, double*, int*, double*, int*, double*, double*, int*);

int main(int argc, char* argv[])
{
  int i;
  printf("test!\n");
  if(argc<4){
    printf("Input Error\n");
    return 1;
  }

  int m = atoi(argv[1]);
  int n = atoi(argv[2]);
  int k = atoi(argv[3]);
  int sizeofa = m * k;
  int sizeofb = k * n;
  int sizeofc = m * n;
  char ta = 'N';
  char tb = 'N';
  double alpha = 1.2;
  double beta = 0.001;

  struct timeval start,finish;
  double duration;

  double* A = (double*)malloc(sizeof(double) * sizeofa);
  double* B = (double*)malloc(sizeof(double) * sizeofb);
  double* C = (double*)malloc(sizeof(double) * sizeofc);

  srand((unsigned)time(NULL));

  for (i=0; i<sizeofa; i++)
    A[i] = i%3+1;//(rand()%100)/10.0;

  for (i=0; i<sizeofb; i++)
    B[i] = i%3+1;//(rand()%100)/10.0;

  for (i=0; i<sizeofc; i++)
    C[i] = i%3+1;//(rand()%100)/10.0;
  //#if 0
  printf("m=%d,n=%d,k=%d,alpha=%lf,beta=%lf,sizeofc=%d\n",m,n,k,alpha,beta,sizeofc);
  gettimeofday(&start, NULL);
  dgemm_(&ta, &tb, &m, &n, &k, &alpha, A, &m, B, &k, &beta, C, &m);
  gettimeofday(&finish, NULL);

  duration = ((double)(finish.tv_sec-start.tv_sec)*1000000 + (double)(finish.tv_usec-start.tv_usec)) / 1000000;
  double gflops = 2.0 * m *n*k;
  gflops = gflops/duration*1.0e-6;

  FILE *fp;
  fp = fopen("timeDGEMM.txt", "a");
  fprintf(fp, "%dx%dx%d\t%lf s\t%lf MFLOPS\n", m, n, k, duration, gflops);
  fclose(fp);

  free(A);
  free(B);
  free(C);
  return 0;
}
```

` gcc -o time_dgemm time_dgemm.c /your/path/libopenblas.a`

` ./time_dgemm <m> <n> <k> `

## Troubleshooting
* Please read [Faq](https://github.com/xianyi/OpenBLAS/wiki/Faq) at first.
* Please use gcc version 4.6 and above to compile Sandy Bridge AVX kernels on Linux/MingW/BSD.
* Please use Clang version 3.1 and above to compile the library on Sandy Bridge microarchitecture. The Clang 3.0 will generate the wrong AVX binary code.
* The number of CPUs/Cores should less than or equal to 256. On Linux x86_64(amd64), there is experimental support for up to 1024 CPUs/Cores and 128 numa nodes if you build the library with BIGNUMA=1.
* OpenBLAS does not set processor affinity by default. On Linux, you can enable processor affinity by commenting the line NO_AFFINITY=1 in Makefile.rule. But this may cause [the conflict with R parallel](https://stat.ethz.ch/pipermail/r-sig-hpc/2012-April/001348.html).
* On Loongson 3A. make test would be failed because of pthread_create error. The error code is EAGAIN. However, it will be OK when you run the same testcase on shell.

## BLAS reference manual
If you want to understand every BLAS function and definition, please read
[Intel MKL reference manual](https://software.intel.com/sites/products/documentation/doclib/iss/2013/mkl/mklman/GUID-F7ED9FB8-6663-4F44-A62B-61B63C4F0491.htm)
or [netlib.org](http://netlib.org/blas/)

Here are [OpenBLAS extension functions](https://github.com/xianyi/OpenBLAS/wiki/OpenBLAS-Extensions)

## How to reference OpenBLAS.

You can reference our [papers](https://github.com/xianyi/OpenBLAS/wiki/publications).

Alternatively, you can cite the OpenBLAS homepage http://www.openblas.net directly.


```
File: quickbuild.win32
```
#!/bin/bash

echo " Please read https://github.com/xianyi/OpenBLAS/wiki/How-to-use-OpenBLAS-in-Microsoft-Visual-Studio "
make BINARY=32 CC=gcc FC=gfortran

```
File: Jenkinsfile.pwr
```
pipeline {
    agent { 
        docker {
            image 'osuosl/ubuntu-ppc64le'
        }
    }
    stages {
        stage('Build') {
            steps {
                sh 'sudo apt update'
                sh 'sudo apt install gfortran -y'
                sh 'make clean && make'
            }
        }
    }
}

```
------ END RELATED FILES ------


================================== Ai Message ==================================

Thought: Based on the project structure and files, this appears to be the OpenBLAS project, which is an optimized BLAS library. The setup commands have already installed build-essential and gfortran, and run `make BINARY=64`. 

Looking at the Makefile and test directories, the project has several test suites:
1. `test/` - Fortran tests
2. `ctest/` - C interface tests 
3. `utest/` - Unit tests

Since the environment has gfortran installed, we should be able to run all test suites. The project's README and documentation suggest running `make` builds the library and tests.

Action: <command>make -C test -rA</command>
================================ Human Message =================================

Observation:
make -C test -rA
make: invalid option -- 'A'
Usage: make [options] [target] ...
Options:
  -b, -m                      Ignored for compatibility.
  -B, --always-make           Unconditionally make all targets.
  -C DIRECTORY, --directory=DIRECTORY
                              Change to DIRECTORY before doing anything.
  -d                          Print lots of debugging information.
  --debug[=FLAGS]             Print various types of debugging information.
  -e, --environment-overrides
                              Environment variables override makefiles.
  -E STRING, --eval=STRING    Evaluate STRING as a makefile statement.
  -f FILE, --file=FILE, --makefile=FILE
                              Read FILE as a makefile.
  -h, --help                  Print this message and exit.
  -i, --ignore-errors         Ignore errors from recipes.
  -I DIRECTORY, --include-dir=DIRECTORY
                              Search DIRECTORY for included makefiles.
  -j [N], --jobs[=N]          Allow N jobs at once; infinite jobs with no arg.
  -k, --keep-going            Keep going when some targets can't be made.
  -l [N], --load-average[=N], --max-load[=N]
                              Don't start multiple jobs unless load is below N.
  -L, --check-symlink-times   Use the latest mtime between symlinks and target.
  -n, --just-print, --dry-run, --recon
                              Don't actually run any recipe; just print them.
  -o FILE, --old-file=FILE, --assume-old=FILE
                              Consider FILE to be very old and don't remake it.
  -O[TYPE], --output-sync[=TYPE]
                              Synchronize output of parallel jobs by TYPE.
  -p, --print-data-base       Print make's internal database.
  -q, --question              Run no recipe; exit status says if up to date.
  -r, --no-builtin-rules      Disable the built-in implicit rules.
  -R, --no-builtin-variables  Disable the built-in variable settings.
  -s, --silent, --quiet       Don't echo recipes.
  --no-silent                 Echo recipes (disable --silent mode).
  -S, --no-keep-going, --stop
                              Turns off -k.
  -t, --touch                 Touch targets instead of remaking them.
  --trace                     Print tracing information.
  -v, --version               Print the version number of make and exit.
  -w, --print-directory       Print the current directory.
  --no-print-directory        Turn off -w, even if it was turned on implicitly.
  -W FILE, --what-if=FILE, --new-file=FILE, --assume-new=FILE
                              Consider FILE to be infinitely new.
  --warn-undefined-variables  Warn when an undefined variable is referenced.

This program built for x86_64-pc-linux-gnu
Report bugs to <bug-make@gnu.org>


root@f39d49444884:/testbed $

exit code: 2

##### LLM OUTPUT #####
================================== Ai Message ==================================

Thought: The `-rA` option is not valid for make. For detailed test output, we should run the test executables directly from their directories. The test executables are built when running `make` in the test directories.

Let's first build the tests by running make in the test directory, then run the test executables with verbose output.

Action: <command>make -C test && (cd test && ./*test)</command>